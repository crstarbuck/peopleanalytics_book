# Read employee tenure data
demographics <- read.csv("https://raw.githubusercontent.com/crstarbuck/peopleanalytics_lifecycle_book/master/data/files/employee_demographics.csv")
# Calculate sample standard deviation for annual compensation
sd(demographics$annual_comp)
# Calculate population standard deviation for annual compensation
sd(demographics$annual_comp) * sqrt((n - 1) / n)
# Calculate population standard deviation for annual compensation
sd(demographics$annual_comp) * sqrt((n - 1) / n)
# Store number of observations
n = nrow(demographics)
# Calculate population variance for annual compensation
var(demographics$annual_comp) * (n - 1) / n
# Calculate sample standard deviation for annual compensation
sd(demographics$annual_comp)
# Calculate population standard deviation for annual compensation
sd(demographics$annual_comp) * sqrt((n - 1) / n)
sigma(demographics$annual_comp)
?sigma
?cov
# Load library for data viz
library(ggplot2)
# Set seed for reproducible random distribution
set.seed(1234)
# Generate uniform population distribution with 1000 values ranging from 1 to 100
rand.unif <- runif(1000, min = 1, max = 100)
# Calculate population mean
mean(rand.unif)
# Calculate population variance
var(rand.unif) * (n - 1) / n
# Load library for data wrangling
library(dplyr)
# Load library for data wrangling
library(dplyr)
# Read employee demographics data
demographics <- read.csv("https://raw.githubusercontent.com/crstarbuck/peopleanalytics_lifecycle_book/master/data/files/employee_demographics.csv")
# Load library for data wrangling
library(dplyr)
# Read employee demographics data
demographics <- read.csv("https://raw.githubusercontent.com/crstarbuck/peopleanalytics_lifecycle_book/master/data/files/employee_demographics.csv")
# Read employee demographics data
demographics <- read.csv("https://raw.githubusercontent.com/crstarbuck/peopleanalytics_lifecycle_book/master/data/files/employee_demographics.csv")
# Store number of observations
n = nrow(demographics)
# Calculate population variance for annual compensation
var(demographics$annual_comp) * (n - 1) / n
# Calculate sample standard deviation for annual compensation
sd(demographics$annual_comp)
# Calculate population standard deviation for annual compensation
sd(demographics$annual_comp) * sqrt((n - 1) / n)
# Return quartiles for annual compensation
quantile(demographics$annual_comp)
# Return 80th percentile annual compensation value
quantile(demographics$annual_comp, probs = .8)
# Return common descriptives
summary(demographics$annual_comp)
# Calculate population covariance between annual compensation and age
cov(demographics$annual_comp, demographics$age, use = "complete.obs") * (n - 1) / n
# Calculate sample covariance between annual compensation and age using complete observations (missing values will cause issues if not addressed)
cov(demographics$annual_comp, demographics$age, use = "complete.obs")
# Calculate population covariance between annual compensation and age
cov(demographics$annual_comp, demographics$age, use = "complete.obs") * (n - 1) / n
# Generate a correlation matrix among continuous variables
cov(demographics[, c("annual_comp", "age", "org_tenure", "job_tenure")], use = "complete.obs")
# Return sample variance for annual compensation
var(demographics$annual_comp)
# Return sample variance for annual compensation
var(demographics$age)
# Return sample variance for annual compensation
var(demographics$age)
?cor
(1-.05)^3
1-(1-.05)^3
.19*3
.17*3
.016*3
.015*3
.014*3
install.packages("moments", dependencies = TRUE)
# Load library
library(moments)
# Load library for data wrangling
library(dplyr)
# Read employee demographics data
demographics <- read.csv("https://raw.githubusercontent.com/crstarbuck/peopleanalytics_lifecycle_book/master/data/files/employee_demographics.csv")
# Return common descriptives
skewness(demographics$annual_comp)
# Store number of observations
n = nrow(demographics)
x = demographics$annual_comp
x-bar = demographics$annual_comp
x-bar = mean(demographics$annual_comp)
x-bar = average(demographics$annual_comp)
x-bar = mean(demographics$annual_comp)
demographics$annual_comp
mean(demographics$annual_comp)
x_bar = mean(demographics$annual_comp)
s = sd(demographics$annual_comp)
1/n * ((x - x_bar)^3 / s^3)
1/n * (sum((x - x_bar)^3) / s^3)
?skewness
# Return common descriptives
round(skewness(demographics$annual_comp), 3)
round(1/n * (sum((x - x_bar)^3) / s^3), 3)
skewness(demographics$job_level)
View(demographics)
skewness(demographics$age)
skewness(demographics$org_tenure)
# Calculate skewness of org tenure, rounded to three significant figures
round(skewness(demographics$org_tenure), 3)
# Store components of skewness calculation
x = demographics$org_tenure
x_bar = mean(demographics$org_tenure)
s = sd(demographics$org_tenure)
# Calculate skewness manually, rounded to three significant figures
round(1/n * (sum((x - x_bar)^3) / s^3), 3)
plot(demographics$org_tenure)
# Load library for data viz
library(ggplot)
# Load library for data viz
library(ggplot)
# Load library for data viz
library(ggplot2)
# Produce histogram to visualize population distribution
ggplot() +
aes(demographics$org_tenure) +
labs(x = "x", y = "N") +
geom_histogram(colour = "white", size = .1, fill = "#262626")
skewness(demographics$age)
# Produce histogram to visualize population distribution
ggplot() +
aes(demographics$org_tenure) +
labs(x = "Organization Tenure", y = "n") +
geom_histogram(colour = "white", size = .1, fill = "#262626")
# Calculate skewness of org tenure, rounded to three significant figures
round(kurtosis(demographics$org_tenure), 3)
kurtosis(demographics$org_tenure)
r
# Calculate kurtosis for org tenure, rounded to three significant figures
round(kurtosis(demographics$org_tenure), 3)
# Calculate kurtosis manually, rounded to three significant figures
round(1/n * (sum((x - x_bar)^3) / s^4), 4)
# Calculate kurtosis manually, rounded to three significant figures
round(1/n * (sum((x - x_bar)^4) / s^4), 3)
# Calculate kurtosis for org tenure, rounded to three significant figures
round(kurtosis(demographics$org_tenure), 3)
# Calculate kurtosis manually, rounded to three significant figures
round(1/n * (sum((x - x_bar)^4) / s^4), 3)
# Calculate kurtosis for org tenure, rounded to three significant figures
round(kurtosis(demographics$org_tenure), 2)
# Calculate kurtosis manually, rounded to three significant figures
round(1/n * (sum((x - x_bar)^4) / s^4), 2)
?sample
# Select correct door
correct_door <- sample(1:3, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(1:3, 1, replace = T)
correct_door
selected_door
# Doors
doors = 1:3
doors
# Number of simulations
trials = 1000
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
correct_door
selected_door
!doors==correct_door
doors == correct_door & doors == selected_door
doors[doors == correct_door & doors == selected_door]
correct_door
selected_door
doors
doors[which(doors == correct_door & doors == selected_door)]
which(doors == correct_door & doors == selected_door)
which(!doors == correct_door & !doors == selected_door)
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
which(!doors == correct_door & !doors == selected_door)
# Open door that was neither selected by the contestant nor contains the prize
which(!doors == correct_door & !doors == selected_door)
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
which(!doors == correct_door & !doors == selected_door)
?sample
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
correct_door
selected_door
# Open door that was neither selected by the contestant nor contains the prize
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
remaining_doors
open_door <- sample(remaining_doors, 1, replace = T) # choose one door to open if multiple remain without the prize
open_door
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
remaining_doors
open_door <- sample(remaining_doors, 1, replace = T) # choose one door to open if multiple remain without the prize
open_door
correct_door
selected_door
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
correct_door
selected_door
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
remaining_doors
open_door
decision == "switch"
decision = "switch"
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", remaining_doors[!open_door], selected_door)
selected_door
which[!remaining_doors == open_door]
which[!remaining_doors %in% open_door]
remaining_doors
open_door
remaining_doors[!open_door]
remaining_doors
open_door
remaining_doors[!remaining_doors == open_door]
which(!remaining_doors == open_door)
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!remaining_doors == open_door), selected_door)
correct_door
selected_door
selected_door
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
correct_door
selected_door
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
remaining_doors
open_door <- sample(remaining_doors, 1, replace = T)
open_door
ifelse(decision == "switch", which(!remaining_doors == open_door), selected_door)
decision == "switch"
which(!remaining_doors == open_door)
remaining_doors
open_door
correct_door
selected_door
remaining_doors
which(!doors == selected_door & !doors == open_door)
correct_door
selected_door
open_door
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
selected_door
correct_door
# Set number of simulations
trials = 1000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
results = ifelse(correct_door == selected_door, "win", "lose")))
}
}
# Set number of simulations
trials = 1000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
result = ifelse(correct_door == selected_door, "win", "lose")))
}
}
nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results)
nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results)
nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
# Set number of simulations
trials = 10000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
result = ifelse(correct_door == selected_door, "win", "lose")))
}
}
nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
(switch_wins - keep_wins) / switch_wins * 100
(switch_wins - keep_wins) / switch_wins * 100
# Calculate percent of wins for switch vs. keep decisions
switch_wins <- nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
keep_wins <- nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
(switch_wins - keep_wins) / switch_wins * 100
round((switch_wins - keep_wins) / switch_wins * 100, 2)
round((switch_wins - keep_wins) / switch_wins * 100, 0)
# Set seed for reproducible simulations
set.seed(1234)
# Set number of simulations
trials = 10000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
result = ifelse(correct_door == selected_door, "win", "lose")))
}
}
# Calculate percent of wins for switch vs. keep decisions
switch_wins <- nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
keep_wins <- nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
round((switch_wins - keep_wins) / switch_wins * 100, 0)
# Set seed for reproducible simulations
set.seed(1234)
# Set number of simulations
trials = 10000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
result = ifelse(correct_door == selected_door, "win", "lose")))
}
}
# Calculate percent of wins for switch vs. keep decisions
switch_wins <- nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
keep_wins <- nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
round((switch_wins - keep_wins) / switch_wins * 100, 0)
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/scientific_method.png")
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/scientific_method.png")
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/scientific_method.png")
```{r, out.height = "30%", out.width = "30%", echo = FALSE, fig.cap = 'The Scientific Method'}
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/scientific_method.png")
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/4d_framework_overview.png")
# Load library for data wrangling
library(dplyr)
# Read employee demographics data
demographics <- read.csv("https://raw.githubusercontent.com/crstarbuck/peopleanalytics_lifecycle_book/master/data/files/employee_demographics.csv")
# Calculate sample variance for annual compensation
var(demographics$annual_comp)
melt()
?melt()
?melt
View(demographics)
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = division, y = annual_comp, color = division)) +
geom_boxplot()
# Load library for data viz
library(ggplot2)
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = division, y = annual_comp, color = division)) +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = division, y = annual_comp, color = division)) +
labs(x = "Division", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = education, y = annual_comp, color = education)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = as.factor(education))) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = business_unit)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = location)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender) +
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender) +
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender) +
# Load library for data viz
library(ggplot2)
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender)) +
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
