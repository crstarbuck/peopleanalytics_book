ggplot2::geom_bar(stat = "identity") +
ggplot2::scale_fill_manual(values = c("Human Resources" = "#BFBFBF",
"Life Sciences" = "#0070C0",
"Marketing" = "#BFBFBF",
"Medical" = "#BFBFBF",
"Other" = "#BFBFBF",
"Technical Degree" = "#BFBFBF")) +
ggplot2::theme(legend.position = "none")
# Step 4: Add Axis Titles and Margins
ggplot2::ggplot(smmry_ed_field, aes(x = ed_field, y = n, fill = as.factor(ed_field))) +
ggplot2::geom_bar(stat = "identity") +
ggplot2::labs(x = 'Education Field', y = 'Headcount') +
ggplot2::scale_fill_manual(values = c("Human Resources" = "#BFBFBF",
"Life Sciences" = "#0070C0",
"Marketing" = "#BFBFBF",
"Medical" = "#BFBFBF",
"Other" = "#BFBFBF",
"Technical Degree" = "#BFBFBF")) +
ggplot2::theme(legend.position = "none",
axis.title.x = ggplot2::element_text(margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y = ggplot2::element_text(margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0)))
# Step 5: Add Left-Justified Title
ggplot2::ggplot(smmry_ed_field, aes(x = ed_field, y = n, fill = as.factor(ed_field))) +
ggplot2::geom_bar(stat = "identity") +
ggplot2::labs(title = 'Life Sciences is the most common education field \npursued by active employees.', x = 'Education Field', y = 'Headcount') +
ggplot2::scale_fill_manual(values = c("Human Resources" = "#BFBFBF",
"Life Sciences" = "#0070C0",
"Marketing" = "#BFBFBF",
"Medical" = "#BFBFBF",
"Other" = "#BFBFBF",
"Technical Degree" = "#BFBFBF")) +
ggplot2::theme(legend.position = "none",
plot.title = ggplot2::element_text(hjust = 0),
axis.title.x = ggplot2::element_text(margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y = ggplot2::element_text(margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0)))
# Step 6: Remove Background
ggplot2::ggplot(smmry_ed_field, aes(x = ed_field, y = n, fill = as.factor(ed_field))) +
ggplot2::geom_bar(stat = "identity") +
ggplot2::labs(title = 'Life Sciences is the most common education field \npursued by active employees.', x = 'Education Field', y = 'Headcount') +
ggplot2::scale_fill_manual(values = c("Human Resources" = "#BFBFBF",
"Life Sciences" = "#0070C0",
"Marketing" = "#BFBFBF",
"Medical" = "#BFBFBF",
"Other" = "#BFBFBF",
"Technical Degree" = "#BFBFBF")) +
ggplot2::theme(legend.position = "none",
panel.background = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y = ggplot2::element_text(margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0)))
# Step 7: Remove Axis Ticks
ggplot2::ggplot(smmry_ed_field, aes(x = ed_field, y = n, fill = as.factor(ed_field))) +
ggplot2::geom_bar(stat = "identity") +
ggplot2::labs(title = 'Life Sciences is the most common education field \npursued by active employees.', x = 'Education Field', y = 'Headcount') +
ggplot2::scale_fill_manual(values = c("Human Resources" = "#BFBFBF",
"Life Sciences" = "#0070C0",
"Marketing" = "#BFBFBF",
"Medical" = "#BFBFBF",
"Other" = "#BFBFBF",
"Technical Degree" = "#BFBFBF")) +
ggplot2::theme(legend.position = "none",
panel.background = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y = ggplot2::element_text(margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0)),
axis.ticks.x = ggplot2::element_blank(),
axis.ticks.y = ggplot2::element_blank())
# Step 8: Mute Titles
ggplot2::ggplot(smmry_ed_field, aes(x = ed_field, y = n, fill = as.factor(ed_field))) +
ggplot2::geom_bar(stat = "identity") +
ggplot2::labs(title = 'Life Sciences is the most common education field \npursued by active employees.', x = 'Education Field', y = 'Headcount') +
ggplot2::scale_fill_manual(values = c("Human Resources" = "#BFBFBF",
"Life Sciences" = "#0070C0",
"Marketing" = "#BFBFBF",
"Medical" = "#BFBFBF",
"Other" = "#BFBFBF",
"Technical Degree" = "#BFBFBF")) +
ggplot2::theme(legend.position = "none",
panel.background = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0), colour = "#404040"),
axis.title.y = ggplot2::element_text(margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0), colour = "#404040"),
plot.title = ggplot2::element_text(hjust = 0, colour = "#404040"),
axis.ticks.x = ggplot2::element_blank(),
axis.ticks.y = ggplot2::element_blank())
# Step 9: Flip Axes
ggplot2::ggplot(smmry_ed_field, aes(x = ed_field, y = n, fill = as.factor(ed_field))) +
ggplot2::geom_bar(stat = "identity") +
ggplot2::coord_flip() +
ggplot2::labs(title = 'Life Sciences is the most common education field \npursued by active employees.', x = 'Education Field', y = 'Headcount') +
ggplot2::scale_fill_manual(values = c("Human Resources" = "#BFBFBF",
"Life Sciences" = "#0070C0",
"Marketing" = "#BFBFBF",
"Medical" = "#BFBFBF",
"Other" = "#BFBFBF",
"Technical Degree" = "#BFBFBF")) +
ggplot2::theme(legend.position = "none",
panel.background = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0), colour = "#404040"),
axis.title.y = ggplot2::element_text(margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0), colour = "#404040"),
plot.title = ggplot2::element_text(hjust = 0, colour = "#404040"),
axis.ticks.x = ggplot2::element_blank(),
axis.ticks.y = ggplot2::element_blank())
# Step 10: Sort Data
ggplot2::ggplot(smmry_ed_field, aes(x = reorder(ed_field, n), y = n, fill = as.factor(ed_field))) +
ggplot2::geom_bar(stat = "identity") +
ggplot2::coord_flip() +
ggplot2::labs(title = 'Life Sciences is the most common education field \npursued by active employees.', x = 'Education Field', y = 'Headcount') +
ggplot2::scale_fill_manual(values = c("Human Resources" = "#BFBFBF",
"Life Sciences" = "#0070C0",
"Marketing" = "#BFBFBF",
"Medical" = "#BFBFBF",
"Other" = "#BFBFBF",
"Technical Degree" = "#BFBFBF")) +
ggplot2::theme(legend.position = "none",
panel.background = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0), colour = "#404040"),
axis.title.y = ggplot2::element_text(margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0), colour = "#404040"),
plot.title = ggplot2::element_text(hjust = 0, colour = "#404040"),
axis.ticks.x = ggplot2::element_blank(),
axis.ticks.y = ggplot2::element_blank())
# Pre/post viz comparison
viz_pre <- ggplot2::ggplot(smmry_ed_field, aes(x = ed_field, y = n, fill = as.factor(ed_field))) +
ggplot2::geom_bar(stat = "identity")
viz_post <- ggplot2::ggplot(smmry_ed_field, aes(x = reorder(ed_field, n), y = n, fill = as.factor(ed_field))) +
ggplot2::geom_bar(stat = "identity") +
ggplot2::coord_flip() +
ggplot2::labs(title = 'Life Sciences is the most common education field \npursued by active employees.', x = 'Education Field', y = 'Headcount') +
ggplot2::scale_fill_manual(values = c("Human Resources" = "#BFBFBF",
"Life Sciences" = "#0070C0",
"Marketing" = "#BFBFBF",
"Medical" = "#BFBFBF",
"Other" = "#BFBFBF",
"Technical Degree" = "#BFBFBF")) +
ggplot2::theme(legend.position = "none",
panel.background = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0), colour = "#404040"),
axis.title.y = ggplot2::element_text(margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0), colour = "#404040"),
plot.title = ggplot2::element_text(hjust = 0, colour = "#404040"),
axis.ticks.x = ggplot2::element_blank(),
axis.ticks.y = ggplot2::element_blank())
# Display pre/post visualizations side-by-side
ggpubr::ggarrange(viz_post, viz_pre, ncol = 1, nrow = 2)
# Load library
library(ggplot2)
# Generate data with a linear relationship + some noise
X <- rnorm(20, 50, 10)
err = rnorm(20, 0, 15)
Y <- 100 + 4*X + err
# Construct basic data frame
df2 <- data.frame(X = X,
Y = Y)
# Fit simple linear model to data
lm.fit.2 <- lm(Y ~ X, df2)
# Save predicted values and residuals
df2$predicted <- predict(lm.fit.2)
df2$residuals <- residuals(lm.fit.2)
# Visualize model fit to observations
ggplot2::ggplot(data = df2, aes(x = X, y = Y)) +
ggplot2::geom_segment(aes(xend = X, yend = predicted)) +
ggplot2::geom_point(shape = 1) +
ggplot2::geom_point(aes(y = predicted)) +
ggplot2::geom_function(fun = function(x) {lm.fit.2$coefficients[[2]]*x + lm.fit.2$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Load library
library(ggpubr)
# Set seed for reproducibility
set.seed(1234)
# Construct basic data frame
df1 <- data.frame(X = c(25, 75),
Y = c(205, 390))
# Fit simple linear model to data
lm.fit.1 <- lm(Y ~ X, df1)
# Visualize model fit to observations
p1 <- ggplot2::ggplot(data = df1, aes(x = X, y = Y)) +
ggplot2::geom_point(color = "black") +
ggplot2::geom_function(fun = function(x) {lm.fit.1$coefficients[[2]]*x + lm.fit.1$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Generate data with a linear relationship + some noise
X <- rnorm(20, 50, 10)
err = rnorm(20, 0, 15)
Y <- 100 + 4*X + err
# Construct basic data frame
df2 <- data.frame(X = X,
Y = Y)
# Fit simple linear model to data
lm.fit.2 <- lm(Y ~ X, df2)
# Visualize model fit to observations
p2 <- ggplot2::ggplot(data = df2, aes(x = X, y = Y)) +
ggplot2::geom_point() +
ggplot2::geom_function(fun = function(x) {lm.fit.2$coefficients[[2]]*x + lm.fit.2$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Display distribution visualizations
ggpubr::ggarrange(p1, p2, ncol = 2, nrow = 1)
# Load data
library(peopleanalytics)
# Subset employees data frame; leads are only applicable for those in sales positions
data <- subset(employees, job_title %in% c('Sales Executive', 'Sales Representative'))
# Regress YTD leads on engagement
slm.fit <- lm(ytd_leads ~ engagement, data)
# Set seed for reproducibility
set.seed(1234)
# Simulate n observations
n <- 20
X <- runif(n, 0, 5)
Y <- 1 + 3*X + rnorm(n, 0, 1)
df.orig <- data.frame(X = X, Y = Y)
# Model data
model <- lm(Y ~ X)
# Visualize model fit to observations
p1 <- ggplot2::ggplot(data = df.orig, aes(x = X, y = Y)) +
ggplot2::geom_point() +
ggplot2::geom_function(fun = function(x) {model$coefficients[[2]]*x + model$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Model data with non-influential outliers
X.out <- c(X, 8)
Y.out <- c(Y, 25)
df.out <- data.frame(X = X.out, Y = Y.out)
model.out <- lm(Y.out ~ X.out)
# Visualize model fit to observations
p2 <- ggplot2::ggplot(data = df.out, aes(x = X, y = Y)) +
ggplot2::geom_point(col = ifelse(df.out$X == 8, "red", "black"), size = ifelse(df.out$X == 8, 2, 1)) +
ggplot2::geom_function(fun = function(x) {model$coefficients[[2]]*x + model$coefficients[[1]]}, colour = "black", linetype = "solid") +
ggplot2::geom_function(fun = function(x) {model.out$coefficients[[2]]*x + model.out$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Model data with influential (high leverage) observations
X.lev <- c(X, 8)
Y.lev <- c(Y, 5)
df.lev <- data.frame(X = X.lev, Y = Y.lev)
model.lev <- lm(Y.lev ~ X.lev)
# Visualize model fit to observations
p3 <- ggplot2::ggplot(data = df.lev, aes(x = X, y = Y)) +
ggplot2::geom_point(col = ifelse(df.out$X == 8, "red", "black"), size = ifelse(df.out$X == 8, 2, 1)) +
ggplot2::geom_function(fun = function(x) {model$coefficients[[2]]*x + model$coefficients[[1]]}, colour = "black", linetype = "solid") +
ggplot2::geom_function(fun = function(x) {model.lev$coefficients[[2]]*x + model.lev$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Display distribution visualizations
ggpubr::ggarrange(p2, p3, ncol = 2, nrow = 1)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(slm.fit)
# Run the Breusch-Pagan test for evaluate homoscedasticity
lmtest::bptest(slm.fit)
# Square root transformation of YTD leads
slm.fit.trans <- lm(sqrt(ytd_leads) ~ engagement, data)
# Natural logarithmic transformation of YTD leads
slm.fit.trans <- lm(log(ytd_leads) ~ engagement, data)
lm(log(ytd_leads) ~ engagement, data)
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(slm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
# Compute Shapiro-Wilk test of normality
shapiro.test(slm.fit$residuals)
# Produce model summary
summary(slm.fit)
ggplot2::ggplot(data = data, aes(x = engagement, y = ytd_leads)) +
ggplot2::labs(x = "Engagement", y = "YTD Leads") +
ggplot2::geom_point(color = "black") +
ggplot2::geom_function(fun = function(x) {slm.fit$coefficients[[2]]*x + slm.fit$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::annotate("text", x = 1.4, y = 40, label = "y = 20.1x + 1.6", colour = "red") +
ggplot2::theme_bw()
# Load library
library(equatiomatic)
# Convert model to LaTex regression equation
equatiomatic::extract_eq(slm.fit)
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, stock_opt_lvl, job_tenure, org_tenure, mgr_tenure)))
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(ytd_sales ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Load library
library(car)
# Produce VIF for each predictor
car::vif(mlm.fit)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit)) < 3 & abs(cooks.distance(mlm.fit)) < 4/nrow(mlm.fit$model)
mlm.fit <- update(mlm.fit, weights = as.numeric(w))
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Run the Breusch-Pagan test for evaluate homoscedasticity
lmtest::bptest(mlm.fit)
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(mlm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
# Compute Shapiro-Wilk test of normality
shapiro.test(mlm.fit$residuals)
# Produce model summary
summary(mlm.fit)
# Convert model to LaTex regression equation
equatiomatic::extract_eq(mlm.fit)
# Scale variables and store standardized data in new data frame
data_std = data.frame(scale(subset(data, select = (c(ytd_sales, engagement, job_lvl, stock_opt_lvl, org_tenure)))))
# Refit model using scaled variables
mlm.fit.scaled <- lm(ytd_sales ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_std)
# Produce model summary with standardized coefficients
summary(mlm.fit.scaled)
# Regress YTD sales on a combination of predictors with interaction term
mlm.fit.int <- lm(sqrt(ytd_sales) ~ job_lvl * org_tenure, data)
# Produce model summary with standardized coefficients
summary(mlm.fit.int)
# Produce VIF for each model term
car::vif(mlm.fit.int)
# Append centered predictors to data
data$job_lvl_cntrd <- data$job_lvl - mean(data$job_lvl)
data$org_tenure_cntrd <- data$org_tenure - mean(data$org_tenure)
# Regress YTD sales on a combination of centered predictors with interaction term
mlm.fit.int <- lm(sqrt(ytd_sales) ~ job_lvl_cntrd * org_tenure_cntrd, data)
# Produce model summary with standardized coefficients
summary(mlm.fit.int)
# Produce VIF for centered variables
car::vif(mlm.fit.int)
ggplot2::ggplot(data = data, aes(x = job_lvl, y = sqrt(ytd_sales))) +
ggplot2::labs(x = "Job Level", y = "Square Root of YTD Sales") +
ggplot2::geom_function(fun = function(x) {mlm.fit.int$coefficients[[4]] * (mean(data$org_tenure) + sd(data$org_tenure)) * x + mlm.fit.int$coefficients[[1]]}, colour = "red") +
ggplot2::geom_function(fun = function(x) {mlm.fit.int$coefficients[[4]] * (mean(data$org_tenure) - sd(data$org_tenure)) * x + mlm.fit.int$coefficients[[1]]}, colour = "blue") +
ggplot2::annotate("text", x = 1.5, y = 255, label = "High organization tenure", colour = "red") +
ggplot2::annotate("text", x = 1.5, y = 280, label = "Low organization tenure", colour = "blue") +
ggplot2::theme_bw()
# Regress YTD sales on a combination of centered predictors with interaction term
med.fit.one <- lm(sqrt(ytd_sales) ~ ed_lvl, data)
# Produce model summary with standardized coefficients
summary(med.fit.one)
# Regress YTD sales on a combination of centered predictors with interaction term
med.fit.two <- lm(job_lvl ~ ed_lvl, data)
# Produce model summary with standardized coefficients
summary(med.fit.two)
# Regress YTD sales on a combination of centered predictors with interaction term
med.fit.three <- lm(sqrt(ytd_sales) ~ job_lvl, data)
# Produce model summary with standardized coefficients
summary(med.fit.three)
# Regress YTD sales on a combination of centered predictors with interaction term
med.fit.four <- lm(sqrt(ytd_sales) ~ ed_lvl + job_lvl, data)
# Produce model summary with standardized coefficients
summary(med.fit.four)
# Load data
library(peopleanalytics)
# Store data in df with curtailed name
survey_dat <- survey_responses
# Show dimensions of survey data
dim(survey_dat)
# Load library
library(psych)
# Kaiser-Meyer-Olkin (KMO) statistic
psych::KMO(survey_dat)
# Bartlett's Test of Sphericity
psych::cortest.bartlett(cor(survey_dat), nrow(survey_dat))
# Produce scree plot
psych::scree(survey_dat, pc = FALSE)
# Load library
library(ggplot2)
# Perform PCA
pca <- prcomp(survey_dat, scale = TRUE)
# Calculate explained variance for each principal component
pca_var = (pca$sdev^2 / sum(pca$sdev^2)) * 100
# Create scree plot
ggplot2::qplot(1:length(pca_var), pca_var) +
ggplot2::geom_line() +
ggplot2::scale_x_continuous(breaks = 1:length(pca_var)) +
ggplot2::labs(x = "Principal Component", y = "Variance Explained (%)") +
ggplot2::theme_bw()
# Principal axis factoring using 3 factors and oblimin rotation
efa.fit <- psych::fa(survey_dat, nfactors = 3, rotate = 'oblimin')
# Display factor loadings
efa.fit$loadings
psych::fa.diagram(efa.fit)
# Load library
library(GGally)
# Visualize correlation matrix
GGally::ggpairs(subset(survey_dat, select = c("eng_1", "eng_2", "eng_3", "ret_1", "ret_2", "ret_3")))
# Load library
library(lavaan)
# Model specification; each line represents a separate latent factor
model <- paste('engagement =~ eng_1 + eng_2 + eng_3
retention =~ ret_1 + ret_2 + ret_3')
# Fit the model
cfa.fit <- lavaan::cfa(model, data = survey_dat)
# Load library
library(lavaanPlot)
# Visualize path diagram
lavaanPlot::lavaanPlot(model = cfa.fit, coefs = TRUE, stand = TRUE)
cfa.fit <- lavaan::cfa(model, data = survey_dat)
# Summarize the model
summary(cfa.fit, fit.measures = TRUE)
# Filter employee data to numeric variables
idx <- which(sapply(employees, is.numeric)) # store indices of numeric variables
employees <- employees[, idx] # filter df using indices
# Drop unimportant and sparsely populated sales variables
employees <- subset(employees, select = -c(employee_id, standard_hrs, ytd_leads, ytd_sales))
# Center and scale data
employees_trans <- scale(employees, center = TRUE, scale = TRUE)
# Load library
library(factoextra)
# Determine optimal number of clusters
factoextra::fviz_nbclust(employees_trans, kmeans, method = "wss")
# Filter employee data to numeric variables
idx <- which(sapply(employees, is.numeric)) # store indices of numeric variables
employees <- employees[, idx] # filter df using indices
# Drop unimportant and sparsely populated sales variables
employees <- subset(employees, select = -c(employee_id, standard_hrs, ytd_leads, ytd_sales))
# Load data
library(peopleanalytics)
# Store data in df with curtailed name
survey_dat <- survey_responses
# Show dimensions of survey data
dim(survey_dat)
# Load library
library(psych)
# Kaiser-Meyer-Olkin (KMO) statistic
psych::KMO(survey_dat)
# Bartlett's Test of Sphericity
psych::cortest.bartlett(cor(survey_dat), nrow(survey_dat))
# Produce scree plot
psych::scree(survey_dat, pc = FALSE)
# Load library
library(ggplot2)
# Perform PCA
pca <- prcomp(survey_dat, scale = TRUE)
# Calculate explained variance for each principal component
pca_var = (pca$sdev^2 / sum(pca$sdev^2)) * 100
# Create scree plot
ggplot2::qplot(1:length(pca_var), pca_var) +
ggplot2::geom_line() +
ggplot2::scale_x_continuous(breaks = 1:length(pca_var)) +
ggplot2::labs(x = "Principal Component", y = "Variance Explained (%)") +
ggplot2::theme_bw()
# Principal axis factoring using 3 factors and oblimin rotation
efa.fit <- psych::fa(survey_dat, nfactors = 3, rotate = 'oblimin')
# Display factor loadings
efa.fit$loadings
psych::fa.diagram(efa.fit)
# Load library
library(GGally)
# Visualize correlation matrix
GGally::ggpairs(subset(survey_dat, select = c("eng_1", "eng_2", "eng_3", "ret_1", "ret_2", "ret_3")))
# Load library
library(lavaan)
# Model specification; each line represents a separate latent factor
model <- paste('engagement =~ eng_1 + eng_2 + eng_3
retention =~ ret_1 + ret_2 + ret_3')
# Fit the model
cfa.fit <- lavaan::cfa(model, data = survey_dat)
# Load library
library(lavaanPlot)
# Visualize path diagram
lavaanPlot::lavaanPlot(model = cfa.fit, coefs = TRUE, stand = TRUE)
cfa.fit <- lavaan::cfa(model, data = survey_dat)
# Summarize the model
summary(cfa.fit, fit.measures = TRUE)
# Filter employee data to numeric variables
idx <- which(sapply(employees, is.numeric)) # store indices of numeric variables
employees <- employees[, idx] # filter df using indices
# Drop unimportant and sparsely populated sales variables
employees <- subset(employees, select = -c(employee_id, standard_hrs, ytd_leads, ytd_sales))
# Center and scale data
employees_trans <- scale(employees, center = TRUE, scale = TRUE)
# Load library
library(factoextra)
# Determine optimal number of clusters
factoextra::fviz_nbclust(employees_trans, kmeans, method = "wss")
# Perform K-means clustering
km <- kmeans(employees_trans, centers = 3)
# Return n-count of clusters
km$size
# Calculate mean of each cluster using original data
aggregate(employees, by = list(cluster = km$cluster), mean)
# Add cluster assignment to df
employees <- cbind(employees, km_cluster = km$cluster)
# Load library
library(cluster)
# Define linkage methods
# Note: centroid is not available for agnes() function
methods <- c("complete", "single", "average", "ward")
names(methods) <- c("complete", "single", "average", "ward")
# Create function to compute agglomerative coefficient
agg_coeff <- function(x) {
cluster::agnes(employees_trans, method = x)$ac
}
# Compute agglomerative coefficient for each linkage method
sapply(methods, agg_coeff)
# Perform hierarchical clustering using Ward's linkage method
hclust <- cluster::agnes(employees_trans, method = "ward")
cluster::pltree(hclust, main = "Dendrogram")
# Calculate gap statistic across 1-10 clusters
gap_stat <- cluster::clusGap(employees_trans, FUN = hcut, nstart = 25, K.max = 10, B = 50)
# Generate plot of gap statistic against cluster count
factoextra::fviz_gap_stat(gap_stat)
# Compute distance matrix
d_matrix <- dist(employees_trans, method = "euclidean")
# Perform hierarchical clustering using Ward's method
hclust_final <- hclust(d_matrix, method = "ward.D2" )
# Cut the dendrogram into 7 clusters
groups <- cutree(hclust_final, k = 7)
# Append cluster labels to original data
employees <- cbind(employees, hier_cluster = groups)
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_book/graphics/ww2_plane_damage.png")
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_book/graphics/ww2_plane_damage.png")
