selected_door <- sample(doors, 1, replace = T)
correct_door
selected_door
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
remaining_doors
open_door
decision == "switch"
decision = "switch"
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", remaining_doors[!open_door], selected_door)
selected_door
which[!remaining_doors == open_door]
which[!remaining_doors %in% open_door]
remaining_doors
open_door
remaining_doors[!open_door]
remaining_doors
open_door
remaining_doors[!remaining_doors == open_door]
which(!remaining_doors == open_door)
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!remaining_doors == open_door), selected_door)
correct_door
selected_door
selected_door
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
correct_door
selected_door
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
remaining_doors
open_door <- sample(remaining_doors, 1, replace = T)
open_door
ifelse(decision == "switch", which(!remaining_doors == open_door), selected_door)
decision == "switch"
which(!remaining_doors == open_door)
remaining_doors
open_door
correct_door
selected_door
remaining_doors
which(!doors == selected_door & !doors == open_door)
correct_door
selected_door
open_door
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
selected_door
correct_door
# Set number of simulations
trials = 1000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
results = ifelse(correct_door == selected_door, "win", "lose")))
}
}
# Set number of simulations
trials = 1000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
result = ifelse(correct_door == selected_door, "win", "lose")))
}
}
nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results)
nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results)
nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
# Set number of simulations
trials = 10000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
result = ifelse(correct_door == selected_door, "win", "lose")))
}
}
nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
(switch_wins - keep_wins) / switch_wins * 100
(switch_wins - keep_wins) / switch_wins * 100
# Calculate percent of wins for switch vs. keep decisions
switch_wins <- nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
keep_wins <- nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
(switch_wins - keep_wins) / switch_wins * 100
round((switch_wins - keep_wins) / switch_wins * 100, 2)
round((switch_wins - keep_wins) / switch_wins * 100, 0)
# Set seed for reproducible simulations
set.seed(1234)
# Set number of simulations
trials = 10000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
result = ifelse(correct_door == selected_door, "win", "lose")))
}
}
# Calculate percent of wins for switch vs. keep decisions
switch_wins <- nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
keep_wins <- nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
round((switch_wins - keep_wins) / switch_wins * 100, 0)
# Set seed for reproducible simulations
set.seed(1234)
# Set number of simulations
trials = 10000
# Store switch/keep decisions
decisions = c("switch", "keep")
# Store integer for each door
doors = 1:3
# Initialize empty data frame for results
results = NULL
for (n in 1:trials){
for (decision in decisions){
# Select correct door
correct_door <- sample(doors, 1, replace = T)
# Contestant chooses a door at random
selected_door <- sample(doors, 1, replace = T)
# Open door that was neither selected by the contestant nor contains the prize
# Choose one door to open if multiple remain without the prize (i.e., the contestant didn't initially select the door containing the prize)
remaining_doors <- which(!doors == correct_door & !doors == selected_door)
open_door <- sample(remaining_doors, 1, replace = T)
# Contestant makes decision to switch doors or keep with the originally selected door
selected_door <- ifelse(decision == "switch", which(!doors == selected_door & !doors == open_door), selected_door)
# Store results in data frame
results <- rbind(results, cbind.data.frame(
trial = n,
decision = decision,
result = ifelse(correct_door == selected_door, "win", "lose")))
}
}
# Calculate percent of wins for switch vs. keep decisions
switch_wins <- nrow(results[results$decision == "switch" & results$result == "win", ]) / nrow(results) * 100
keep_wins <- nrow(results[results$decision == "keep" & results$result == "win", ]) / nrow(results) * 100
round((switch_wins - keep_wins) / switch_wins * 100, 0)
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/scientific_method.png")
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/scientific_method.png")
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/scientific_method.png")
```{r, out.height = "30%", out.width = "30%", echo = FALSE, fig.cap = 'The Scientific Method'}
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/scientific_method.png")
knitr::include_graphics("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/graphics/4d_framework_overview.png")
# Load library for data wrangling
library(dplyr)
# Read employee demographics data
demographics <- read.csv("https://raw.githubusercontent.com/crstarbuck/peopleanalytics_lifecycle_book/master/data/files/employee_demographics.csv")
# Calculate sample variance for annual compensation
var(demographics$annual_comp)
melt()
?melt()
?melt
View(demographics)
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = division, y = annual_comp, color = division)) +
geom_boxplot()
# Load library for data viz
library(ggplot2)
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = division, y = annual_comp, color = division)) +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = division, y = annual_comp, color = division)) +
labs(x = "Division", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = education, y = annual_comp, color = education)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = as.factor(education))) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = business_unit)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = location)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender) +
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender) +
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender) +
# Load library for data viz
library(ggplot2)
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender)) +
# Produce boxplots to visualize compensation distribution by divission
ggplot(demographics, aes(x = as.factor(education), y = annual_comp, color = gender)) +
labs(x = "Education", y = "Annual Compensation") +
theme_bw() +
geom_boxplot()
?sample
x <- 1:100
x
# Load library for data wrangling
library(dplyr)
# Load library for data wrangling
library(dplyr)
# Read employee demographics data
demographics <- read.csv("https://raw.githubusercontent.com/crstarbuck/peopleanalytics_lifecycle_book/master/data/files/employee_demographics.csv")
View(demographics)
# Sample 100 employees randomly
sample(demographics$employee_id, replace = F)
sample(x)
# Sample 100 employees randomly
sample(demographics$employee_id, replace = F)
?sample
# Sample 10 employees randomly
sample(demographics$employee_id, 10, replace = F)
# Sample 10 employees randomly
n = 10
sample(demographics$employee_id, n, replace = F)
# Sample 10 employees randomly
set.seed(1234)
n = 10
sample(demographics$employee_id, n, replace = F)
# Sample 10 employees randomly
set.seed(1234)
n = 10
sample(demographics$employee_id, n, replace = F)
# Set seed for reproducible results
set.seed(1234)
# Sample 10 employees randomly
n = 10
sample(demographics$employee_id, n, replace = F)
demographics$division
demographics %>% add_tally(wt = division)
table(demographics$division)
summary(demographics$division)
aggregate(demographics$division)
?aggregate
demographics %>% group_by(division) %>% summarise(employee_id = n())
demographics %>% group_by(location %>% summarise(employee_id = n())
demographics %>% group_by(location) %>% summarise(employee_id = n())
demographics %>% group_by(business_unit) %>% summarise(employee_id = n())
demographics %>% group_by(performance) %>% summarise(employee_id = n())
demographics %>% group_by(gender) %>% summarise(employee_id = n())
demographics %>% group_by(location) %>% summarise(employee_id = n())
# Return employee counts by location
demographics %>% group_by(location) %>% summarise(employee_id = n())
# Return employee counts by location
demographics %>% group_by(location) %>% summarise(n())
# Return employee counts by location
demographics %>% group_by(location) %>% summarise(n)
# Return employee counts by location
demographics %>% group_by(location) %>% summarise(n())
# Return employee counts by location
demographics %>% group_by(location) %>% summarise(n = n())
# Obtain and store stratified random sample
strat_sample <- demographics %>%
group_by(location) %>%
sample_frac(size = .5)
# Return sample counts by location
demographics %>%
group_by(location) %>%
summarise(n = n())
# Return sample counts by location
strat_sample %>%
group_by(location) %>%
summarise(n = n())
strat_sample
# Obtain and store stratified random sample
strat_sample <- demographics %>%
group_by(location) %>%
sample_frac(size = .5)
# Return sample counts by location
strat_sample %>%
group_by(location) %>%
summarise(n = n())
# Obtain and store stratified random sample
strat_sample <- demographics %>%
group_by(location) %>%
sample_frac(size = .5)
# Return sample counts by location
strat_sample %>%
group_by(location) %>%
summarise(n = n())
?replicate
replicate(10,sample(1:10, rep = F))
replicate(sample(1:10, rep = F))
replicate(1, sample(1:10, rep = F))
demographics$group <- replicate(1, sample(1:10, rep = F))
demographics$group <- replicate(1, sample(1:10, size = nrow(demographics), replace = F))
demographics$group <- sample(1:10, size = nrow(demographics), replace = F)
demographics$group <- sample(10, size = nrow(demographics), replace = F)
?sample
(1:10
demographics$group <- sample(1:10, 1, replace = F)
sample(1:10, 1, replace = F)
View(demographics)
demographics$group <- sample(1:10, 1, replace = F)
demographics$group <- sample(1:10, nrow(demographics), replace = F)
demographics$groups <- sample(1:10, nrow(demographics), replace = F)
demographics$group <- sample(1:10, size = nrow(demographics), replace = F)
nrow(demographics)
demographics$group <- sample(1:10, size = nrow(demographics), replace = F)
sample(1:10, size = nrow(demographics), replace = F)
sample(1:10, size = nrow(demographics), replace = F)
sample(1:10, size = nrow(demographics), replace = T)
demographics$group <- sample(1:10, size = nrow(demographics), replace = T)
# Randomly assign each employee to 1 of 10 clusters (groups)
demographics$cluster <- sample(1:10, size = nrow(demographics), replace = T)
clusters <- sample(unique(demographics$cluster), size = 5, replace = F)
clusters
demographics %>% filter(cluster %in% clusters)
1733*.5
1522*.5
651*.5
969*.5
# Create systematic sampling function
syst_sample <- function(N, n){
k = ceiling(N/n)
r = sample(1:k, 1)
seq(r, r + k * (n - 1), k)
}
#obtain systematic sample
sys_sample_df = df[syst_sample(nrow(demographics), 100), ]
#obtain systematic sample
sys_sample_df = demographics[syst_sample(nrow(demographics), 100), ]
sys_sample_df
seq()
1001/100
ceiling(1001/100)
# Specify sample size
n = 100
# Determine population size
N = nrow(demographics)
# Specify sample size
n = 100
# Determine population size
N = nrow(demographics)
# Sampling interval
si = N/n
si
ceiling(N/n)
sample(1:si, 1)
sample(1:si, 1)
sample(1:si, 1)
sample(1:si, 1)
sample(1:si, 1)
sample(1:si, 1)
# Specify desired sample size
n = 100
# Determine population size
N = nrow(demographics)
# Compute sampling interval, rounding up to nearest whole number via the ceiling() function
si = ceiling(N/n)
# Create systematic sampling function
syst_sample <- function(N, n){
x = sample(1:si, 1)
seq(x, x + si * (n - 1), si)
}
# Obtain systematic sample
syst_sample <- demographics[syst_sample(N, n), ]
syst_sample
x = sample(1:si, 1)
seq(x, x + si * (n - 1), si)
x = sample(1:si, 1)
x
seq(x, x + si * (n - 1), si)
seq(x, x + si * (n - 1), si)
# Specify observation numbers per sampling interval
seq(x, x + si * (n - 1), si)
# Specify desired sample size
n = 100
# Determine population size
N = nrow(demographics)
# Compute sampling interval, rounding up to nearest whole number via the ceiling() function
si = ceiling(N/n)
# Randomly select value between 1 and the sampling interval
k = sample(1:si, 1)
# Specify observation numbers per sampling interval value
x = seq(k, k + si * (n - 1), si)
# Obtain systematic sample
syst_sample <- demographics[x, ]
syst_sample
# Specify desired sample size
n = 100
# Determine population size
N = nrow(demographics)
# Compute sampling interval, rounding up to nearest whole number via the ceiling() function
si = ceiling(N/n)
# Randomly select value between 1 and the sampling interval
k = sample(1:si, 1)
# Store observation indices per sampling interval value
index = seq(k, k + si * (n - 1), si)
# Obtain systematic sample
syst_sample <- demographics[index, ]
nrow(syst_sample)
View(sys_sample_df)
View(syst_sample)
!is.na(syst_sample)
!is.na(syst_sample$employee_id)
length(!is.na(syst_sample$employee_id))
# Specify desired sample size
n = 100
# Determine population size
N = nrow(demographics)
# Compute sampling interval, rounding up to nearest whole number via the ceiling() function
si = ceiling(N/n)
# Randomly select value between 1 and the sampling interval for starting value
strt = sample(1:si, 1)
# Store observation indices per sampling interval value
index = seq(strt, strt + si * (n - 1), si)
# Store systematic sample
syst_sample <- demographics[index, ]
length(!is.na(syst_sample$employee_id))
View(sys_sample_df)
View(demographics)
