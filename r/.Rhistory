ggarrange(p_normal, p_uniform, p_lnormal, p_t, p_chisq, p_f,
ncol = 3, nrow = 2)
# Simulate student's t distribution
t_dist <- rt(1000, df = 4)
p_t <-
ggplot() +
aes(t_dist) +
labs(title = "Student's T", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
# Display distribution visualizations
ggarrange(p_normal, p_uniform, p_lnormal, p_t, p_chisq, p_f,
ncol = 3, nrow = 2)
# Set seed for reproducible random distribution
set.seed(1234)
# Simulate normal distribution
normal_dist <- rnorm(1000, mean = 50, sd = 5)
# Simulate uniform distribution
uniform_dist <- runif(1000, min = 1, max = 100)
# Simulate log-normal distribution
lnormal_dist <- rlnorm(1000, meanlog = 0, sdlog = 1)
# Simulate student's t distribution
t_dist <- rt(1000, df = 3)
# Simulate chi-square distribution
chisq_dist <- rchisq(1000, df = 5)
# Simulate F distribution
f_dist <- rf(1000, df1 = 5, df2 = 200)
# Store visualizations to objects
p_normal <-
ggplot() +
aes(normal_dist) +
labs(title = "Normal", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
p_uniform <-
ggplot() +
aes(uniform_dist) +
labs(title = "Uniform", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
p_lnormal <-
ggplot() +
aes(lnormal_dist) +
labs(title = "Log-Normal", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
p_t <-
ggplot() +
aes(t_dist) +
labs(title = "Student's T", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
p_chisq <-
ggplot() +
aes(chisq_dist) +
labs(title = "Chi-Square", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
p_f <-
ggplot() +
aes(f_dist) +
labs(title = "F", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
# Display distribution visualizations
ggarrange(p_normal, p_uniform, p_lnormal, p_t, p_chisq, p_f,
ncol = 3, nrow = 2)
# Create function to build visualization
build.viz <- function(data, type, title) {
if (type == "discrete"){
# Discrete distribution
viz <- ggplot() +
aes(data) +
labs(title = paste(title), x = "x", y = "count") +
geom_histogram(fill = "#414141") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
} else {
# Continuous distribution
viz <- ggplot() +
aes(normal_dist) +
labs(title = "Normal", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
}
return(viz)
}
# Store visualizations to objects
p_bernoulli <- build.viz(bernoulli_dist, "discrete", "Bernoulli")
# Display distribution visualizations
ggarrange(p_bernoulli, p_binomial, p_nbinomial, p_multinomial, p_poisson, p_geometric,
ncol = 3, nrow = 2)
# Set seed for reproducible random distribution
set.seed(1234)
# Simulate bernoulli distribution
bernoulli_dist <- rbinom(1000, 1, prob = .5)
# Simulate binomial distribution
# Notice the important difference relative to the Bernoulli simulation (100 trials vs. 1)
binomial_dist <- rbinom(1000, 100, prob = .5)
# Simulate negative binomial distribution
nbinomial_dist <- rnbinom(1000, 100, prob = .5)
# Simulate multinomial distribution with varying probabilities per level
multinomial_dist <- rmultinom(1000, 4, prob = c(.4, .3, .2, .6))
# Simulate poisson distribution
poisson_dist <- rpois(1000, 10)
# Simulate geometric distribution
geometric_dist <- rgeom(1000, prob = .2)
# Load library for arranging visuals
library(ggpubr)
# Create helper function to simplify visualization development
build.viz <- function(data, type, title) {
if (type == "discrete"){
# Discrete distribution
viz <- ggplot() +
aes(data) +
labs(title = paste(title), x = "x", y = "count") +
geom_histogram(fill = "#414141") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
} else {
# Continuous distribution
viz <- ggplot() +
aes(normal_dist) +
labs(title = "Normal", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
}
return(viz)
}
# Store visualizations to objects
p_bernoulli <- build.viz(bernoulli_dist, "discrete", "Bernoulli")
p_binomial <- build.viz(binomial_dist, "discrete", "Binomial")
p_multinomial <- build.viz(multinomial_dist, "discrete", "Multinomial")
p_geometric <- build.viz(geometric_dist, "discrete", "Geometric")
# Display distribution visualizations
ggarrange(p_bernoulli, p_binomial, p_nbinomial, p_multinomial, p_poisson, p_geometric,
ncol = 3, nrow = 2)
# Set seed for reproducible random distribution
set.seed(1234)
# Simulate bernoulli distribution
bernoulli_dist <- rbinom(1000, 1, prob = .5)
# Simulate binomial distribution
# Notice the important difference relative to the Bernoulli simulation (100 trials vs. 1)
binomial_dist <- rbinom(1000, 100, prob = .5)
# Simulate negative binomial distribution
nbinomial_dist <- rnbinom(1000, 100, prob = .5)
# Simulate multinomial distribution with varying probabilities per level
multinomial_dist <- rmultinom(1000, 4, prob = c(.4, .3, .2, .6))
# Simulate poisson distribution
poisson_dist <- rpois(1000, 10)
# Simulate geometric distribution
geometric_dist <- rgeom(1000, prob = .2)
# Load library for arranging visuals
library(ggpubr)
# Create user-defined function (UDF) to simplify probability distribution visualization
# Function arguments: (1) data = object containing random distribution values; (2) type = 'discrete' or 'continuous' probability distribution; and (3) title = name of distribution
build.viz <- function(data, type, title) {
if (type == "discrete"){
# Discrete distribution
viz <- ggplot() +
aes(data) +
labs(title = paste(title), x = "x", y = "count") +
geom_histogram(fill = "#414141") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
} else {
# Continuous distribution
viz <- ggplot() +
aes(normal_dist) +
labs(title = "Normal", x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
}
return(viz)
}
# Call UDF to build visualizations and store to objects
p_bernoulli <- build.viz(data = bernoulli_dist, type = "discrete", title = "Bernoulli")
p_binomial <- build.viz(data = binomial_dist, type = "discrete", title = "Binomial")
p_nbinomial <- build.viz(data = nbinomial_dist, type = "discrete", title = "Negative Binomial")
p_multinomial <- build.viz(data = multinomial_dist, type = "discrete", title = "Multinomial")
p_geometric <- build.viz(data = geometric_dist, type = "discrete", title = "Geometric")
# Display distribution visualizations
ggarrange(p_bernoulli, p_binomial, p_nbinomial, p_multinomial, p_poisson, p_geometric,
ncol = 3, nrow = 2)
p_poisson <- build.viz(data = poisson_dist, type = "discrete", title = "Poisson")
p_geometric <- build.viz(data = geometric_dist, type = "discrete", title = "Geometric")
# Display distribution visualizations
ggarrange(p_bernoulli, p_binomial, p_nbinomial, p_multinomial, p_poisson, p_geometric,
ncol = 3, nrow = 2)
# Set seed for reproducible random distribution
set.seed(1234)
# Simulate normal distribution
normal_dist <- rnorm(1000, mean = 50, sd = 5)
# Simulate log-normal distribution
lnormal_dist <- rlnorm(1000, meanlog = 0, sdlog = 1)
# Simulate uniform distribution
uniform_dist <- runif(1000, min = 1, max = 100)
# Simulate student's t distribution
t_dist <- rt(1000, df = 3)
# Simulate chi-square distribution
chisq_dist <- rchisq(1000, df = 5)
# Simulate F distribution
f_dist <- rf(1000, df1 = 5, df2 = 200)
# Call UDF to build visualizations and store to objects
# Note that as long as the arguments are in the order specified in the function (see our UDF definition above), the argument names do not need to be specified. To illustrate, we will drop the argument names from these function calls:
p_normal <- build.viz(normal_dist, "continuous", "Normal")
p_lnormal <- build.viz(lnormal_dist, "continuous", "Log-Normal")
p_uniform <- build.viz(uniform_dist, "continuous", "Uniform")
p_chisq <- build.viz(chisq_dist, "continuous", "Chi-Square")
p_f <- build.viz(f_dist, "continuous", "F")
# Display distribution visualizations
ggarrange(p_normal, p_lnormal, p_uniform, p_t, p_chisq, p_f,
ncol = 3, nrow = 2)
p_t <- build.viz(t_dist, "continuous", "Student's T")
p_chisq <- build.viz(chisq_dist, "continuous", "Chi-Square")
p_f <- build.viz(f_dist, "continuous", "F")
# Display distribution visualizations
ggarrange(p_normal, p_lnormal, p_uniform, p_t, p_chisq, p_f,
ncol = 3, nrow = 2)
# Call UDF to build visualizations and store to objects
# Note that as long as the arguments are in the order specified in the function (see our UDF definition above), the argument names do not need to be specified. To illustrate, we will drop the argument names from these function calls:
p_normal <- build.viz(normal_dist, "continuous", "Normal")
p_lnormal <- build.viz(lnormal_dist, "continuous", "Log-Normal")
p_uniform <- build.viz(uniform_dist, "continuous", "Uniform")
p_t <- build.viz(t_dist, "continuous", "Student's T")
p_chisq <- build.viz(chisq_dist, "continuous", "Chi-Square")
p_f <- build.viz(f_dist, "continuous", "F")
# Display distribution visualizations
ggarrange(p_normal, p_lnormal, p_uniform, p_t, p_chisq, p_f,
ncol = 3, nrow = 2)
# Create user-defined function (UDF) to simplify probability distribution visualization
# Function arguments: (1) data = object containing random distribution values; (2) type = 'discrete' or 'continuous' probability distribution; and (3) title = name of distribution
build.viz <- function(data, type, title) {
if (type == "discrete"){
# Discrete distribution
viz <- ggplot() +
aes(data) +
labs(title = paste(title), x = "x", y = "count") +
geom_histogram(fill = "#414141") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
} else {
# Continuous distribution
viz <- ggplot() +
aes(data) +
labs(title = paste(title), x = "x", y = "density") +
geom_histogram(aes(y = ..density..), fill = "#414141") +
geom_density(fill = "#ADD8E6", alpha = 0.6) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5))
}
return(viz)
}
# Call UDF to build visualizations and store to objects
# Note that as long as the arguments are in the order specified in the function (see our UDF definition above), the argument names do not need to be specified. To illustrate, we will drop the argument names from these function calls:
p_normal <- build.viz(normal_dist, "continuous", "Normal")
p_lnormal <- build.viz(lnormal_dist, "continuous", "Log-Normal")
p_uniform <- build.viz(uniform_dist, "continuous", "Uniform")
p_t <- build.viz(t_dist, "continuous", "Student's T")
p_chisq <- build.viz(chisq_dist, "continuous", "Chi-Square")
p_f <- build.viz(f_dist, "continuous", "F")
# Display distribution visualizations
ggarrange(p_normal, p_lnormal, p_uniform, p_t, p_chisq, p_f,
ncol = 3, nrow = 2)
# Simulate student's t distribution
t_dist <- rt(1000, df = 5)
p_t <- build.viz(t_dist, "continuous", "Student's T")
# Display distribution visualizations
ggarrange(p_normal, p_lnormal, p_uniform, p_t, p_chisq, p_f,
ncol = 3, nrow = 2)
library(GGally)
install.packages("GGally", dependencies = TRUE)
# Load library for data wrangling
library(dplyr)
# Read employee demographics data
demographics <- read.csv("https://raw.githubusercontent.com/crstarbuck/peopleanalytics_lifecycle_book/master/data/files/employee_demographics.csv")
# Calculate sample variance for annual compensation
var(demographics$annual_comp)
# Load library for correlation visuals
library(corrplot)
# Store correlation matrix to object M
M <- cor(demographics[, c("annual_comp", "age", "org_tenure", "job_tenure")], use = "complete.obs")
# Visualize correlation matrix
corrplot.mixed(M, order = 'AOE')
# Load library for correlation visuals
library(GGally)
# Visualize correlation matrix
ggpairs(M)
# Visualize correlation matrix
ggpairs(demographics[, c("annual_comp", "age", "org_tenure", "job_tenure")])
# Install required packages
install.packages(c("tidyverse", "corrplot", "psych", "moments", "ggpubr", "GGally"), dependencies = TRUE, repos = "http://cran.us.r-project.org")
mean(35,5,21,6)
Mean(35,5,21,6)
obj_1 <- 1
obj_2 <- 'c'
obj_3 <- d
obj_3 <- c(2,4,6,8,10)
?vector
# Create and fill a date vector named vect_dt
vect_dt <- seq(as.Date("2021-01-01"), as.Date("2022-01-01"), by = "months")
vect_dt
as.date("2021-01-01")
# Create and fill a date vector named vect_dt
vect_dt <- c(as.Date("2021-01-01"), as.Date("2022-01-01"))
?seq
# Create and fill a date vector named vect_dt
vect_dt <- seq(as.Date("2021-01-01"), as.Date("2022-01-01"), by = months)
# Create and fill a date vector named vect_dt
vect_dt <- seq(as.Date("2021-01-01"), as.Date("2022-01-01"), by = 'months')
vect_dt # Display contents of vect_dt
?mean
?mean
?matrix
# Create and fill matrix with numbers
mtrx_num <- matrix(data = 1:10, nrow = 5, ncol = 2)
mtrx_num
# Create and fill a numeric vector with values between 1 and 10
vect_num <- 1:10
vect_num
a:d
1.1:2.0
# Create and fill a numeric vector with values between 1 and 10
x1 <- 1:10
x2 <- 11:20
x1
x2
x1 + x2
x*2
# Create and fill a numeric vector with values between 1 and 10
x <- 1:10
x*2
# Add 1 to each element of x
x+1
# Multiply each element of x by 2
x*2
# Square each element of x
x^2
# Add 2 to each element of x
x+2
# Multiply each element of x by 2
x*2
# Square each element of x
x^2
# Create a numeric vector named x and fill with values between 1 and 10
x <- 1:10
# Add 2 to each element of x
x+2
# Multiply each element of x by 2
x*2
# Square each element of x
x^2
typeof(x)
class(x)
mode(x)
typeof(mtrx_num)
mode(mtrx_num)
class(mtrx_num)
class(x)
class(vect_dt)
typeof(vect_dt)
# Add 2 to each element of x
x+2 <- x+2
# Add 2 to each element of x
x_plus2 <- x+2
# Multiply each element of x by 2
x_times2 <- x*2
x_times2
# Square each element of x
x_sq <- x^2
x_sq
class(obj_2)
typeof(obj_2)
# Create and fill matrix with numbers
factor(c("full-time", "part-time"))
# Create and fill matrix with numbers
time_type <- factor(c("full-time", "part-time"))
time_type
# Create and fill factor with unordered categories
education <- factor(c("undergraduate", "post-graduate", "graduate"))
education
# Create and fill factor with unordered categories
education <- factor(education, ordered = TRUE, levels = c("undergraduate", "graduate", "post-graduate"))
education
# Store results of x<6 evaluation to logical vector
logical_rslts <- x<6
# Create a numeric vector named x and fill with values between 1 and 10
x <- 1:10
# Store results of x<6 evaluation to logical vector
logical_rslts <- x<6
logical_rslts
x <- 1:10
y <- c('a','b','c','d','e','f','g','h','i','j')
z <- seq(as.Date("2021-01-01"), as.Date("2021-01-01"), by = 'months')
z
z
z <- seq(as.Date("2021-01-01"), as.Date("2021-10-01"), by = 'months')
z
x
y
df <- data.frame(x, y, z)
df
str(df)
# Store vectors x, y, and z as well as df to a list
lst <- list(x, y, z, df)
lst
str(lst)
# Create and fill a numeric vector with values between 1 and 10
vect_num[5]
# Create and fill a numeric vector with values between 1 and 10
vect_num <- 1:10
# Create and fill a numeric vector with values between 1 and 10
vect_num[5]
# Return the value in the last position of vect_num
vect_num[length(vect_num)]
# Access the third element of lst
lst[[3]]
# Return data from the third element of lst
lst[[4]]
# Return data from the third element of lst
lst[[3]]
# Square the values 1 through 5 using a 'for' loop
for (i in 1:5) { i^2 }
# Square the values 1 through 5 using a 'for' loop
for (i in 1:5) { print(i^2) }
# Initialize variable
i <- 1
# Using a 'while' loop, square the values 1 through 5 and print results to the screen
while (i < 6) {
print(i^2)
i <- i + 1
}
# Create and fill matrix with numbers
mtrx_num <- matrix(1:10, 5, 2)
mtrx_num
# Return the number of rows in mtrx_num
nrow(mtrx_num)
# Return the number of rows in mtrx_num
ncol(mtrx_num)
# Return the number of rows in mtrx_num
dim(mtrx_num)
# Create a function named square.val() to square given x values
square.val <- function(x) {
x^2
}
square.val(1:5)
sqrt(1:5)
1:5^2
(1:5)^2
# Using a 'for' loop, square the values 1 through 5 and print results to the screen
for (i in 1:5) {
print(i^2)
}
# Create a function named square.val() with one argument (x) that squares given x values
square.val <- function(x) {
x^2
}
# Pass integers 1 through 5 into the new square.val() function and display results
square.val(1:5)
# Square integers
(1:5)^2
# Load library for data viz
library(ggplot2)
# Create two vectors containing integers
x1 <- 1:10
x2 <- 11:20
# Add vectors
x1 + x2
# Add vectors
x3 <- x1 + x2
x3
# Sum the elements of x
sum(x)
# Create a numeric vector named x and fill with values between 1 and 10
x <- 1:10
# Sum the elements of x
sum(x)
# Count the elements of x
count(x)
# Count the elements of x
length(x)
# Sum the elements of x
sqrt(x)
# Square root of the elements of x
exp(x)
?exp
5^10
?sum
seq(1, 2)
seq(1, 10)
test <- c("215", "3526326")
mode(test)
