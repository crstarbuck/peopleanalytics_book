ggplot2::theme(legend.position = "none")
# Increment counter variable by 1
i = i + 1
}
}
# Visualize density plots side-by-side
ggpubr::ggarrange(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], p[[6]], p[[7]], p[[8]], p[[9]],
ncol = 3, nrow = 3)
t_test
View(employees)
comp_a <- subset(employees, job_title == 'Manager', select = annual_comp)
comp_a <- subset(employees, job_title == Manager, select = annual_comp)
comp_a <- subset(employees, job_title == 'Manager', select = annual_comp)
comp_rsci <- subset(employees, job_title == 'Research Scientist', select = annual_comp)
# Run Welch's t-test
t.test(comp_mgr, comp_rsci)
comp_mgr <- subset(employees, job_title == 'Manager', select = annual_comp)
comp_rsci <- subset(employees, job_title == 'Research Scientist', select = annual_comp)
# Run Welch's t-test
t.test(comp_mgr, comp_rsci)
mean(comp_mgr)
str(comp_mgr)
class(comp_mgr)
mode(comp_mgr)
# Create compensation vectors for two jobs
comp_mgr <- unlist(subset(employees, job_title == 'Manager', select = annual_comp))
comp_rsci <- unlist(subset(employees, job_title == 'Research Scientist', select = annual_comp))
# Run Welch's t-test
t.test(comp_mgr, comp_rsci)
mean(comp_mgr)
round(mean(comp_mgr), 0)
# Load library
library(dplyr)
library(ggplot2)
# Set seed for reproducible random numbers
set.seed(123)
# Fill sample size vector
n_counts <- c(100, 1000, 10000)
# Fill sd vector
sds <- c(50, 100, 150)
# Initialize lists
p = list()
t_test = list()
# Initialize index
i = 1
for (n in n_counts){
for (sd in sds){
# Draw random numbers from normal distribution per defined parameters
a <- data.frame(x = rnorm(n, 100, sd))
b <- data.frame(x = rnorm(n, 130, sd))
# Label groups and combine within single df
a$group <- 'a'
b$group <- 'b'
ab <- rbind(a, b)
# Store mean values in df
mean_df <- ab %>%
group_by(group) %>%
summarize(mean = mean(x))
# Calculate absolute mean difference
xbar_delta <- abs(round(mean(ab[ab$group == 'b', 'x']) - mean(ab[ab$group == 'a', 'x']), 0))
t_test <- t.test(ab[ab$group == 'a', 'x'], ab[ab$group == 'b', 'x'])
# Store viz to object
p[[i]] <- ggplot2::ggplot(ab, aes(x, fill = group)) +
ggplot2::labs(title = paste0("MD = ", xbar_delta, "\n t = ", round(t_test$statistic, 1), ifelse(t_test$p.value < .05, ", p < .05", ", p > .05")), x = "x", y = "Density") +
ggplot2::geom_density(alpha = 0.6) +
ggplot2::scale_fill_manual(values = c("skyblue", "lightgrey")) +
ggplot2::geom_vline(data = mean_df, aes(xintercept = mean), colour = c("blue", "#3D3D3D"), size = .5, linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::theme(legend.position = "none")
# Increment counter variable by 1
i = i + 1
}
}
# Visualize density plots side-by-side
ggpubr::ggarrange(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], p[[6]], p[[7]], p[[8]], p[[9]],
ncol = 3, nrow = 3)
# Load library
library(dplyr)
library(ggplot2)
# Set seed for reproducible random numbers
set.seed(123)
# Fill sample size vector
n_counts <- c(100, 1000, 10000)
# Fill sd vector
sds <- c(50, 100, 150)
# Initialize lists
p = list()
t_test = list()
# Initialize index
i = 1
for (n in n_counts){
for (sd in sds){
# Draw random numbers from normal distribution per defined parameters
a <- data.frame(x = rnorm(n, 100, sd))
b <- data.frame(x = rnorm(n, 125, sd))
# Label groups and combine within single df
a$group <- 'a'
b$group <- 'b'
ab <- rbind(a, b)
# Store mean values in df
mean_df <- ab %>%
group_by(group) %>%
summarize(mean = mean(x))
# Calculate absolute mean difference
xbar_delta <- abs(round(mean(ab[ab$group == 'b', 'x']) - mean(ab[ab$group == 'a', 'x']), 0))
t_test <- t.test(ab[ab$group == 'a', 'x'], ab[ab$group == 'b', 'x'])
# Store viz to object
p[[i]] <- ggplot2::ggplot(ab, aes(x, fill = group)) +
ggplot2::labs(title = paste0("MD = ", xbar_delta, "\n t = ", round(t_test$statistic, 1), ifelse(t_test$p.value < .05, ", p < .05", ", p > .05")), x = "x", y = "Density") +
ggplot2::geom_density(alpha = 0.6) +
ggplot2::scale_fill_manual(values = c("skyblue", "lightgrey")) +
ggplot2::geom_vline(data = mean_df, aes(xintercept = mean), colour = c("blue", "#3D3D3D"), size = .5, linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::theme(legend.position = "none")
# Increment counter variable by 1
i = i + 1
}
}
# Visualize density plots side-by-side
ggpubr::ggarrange(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], p[[6]], p[[7]], p[[8]], p[[9]],
ncol = 3, nrow = 3)
# Load library
library(dplyr)
library(ggplot2)
# Set seed for reproducible random numbers
set.seed(123)
# Fill sample size vector
n_counts <- c(100, 1000, 10000)
# Fill sd vector
sds <- c(25, 50, 75)
# Initialize lists
p = list()
t_test = list()
# Initialize index
i = 1
for (n in n_counts){
for (sd in sds){
# Draw random numbers from normal distribution per defined parameters
a <- data.frame(x = rnorm(n, 100, sd))
b <- data.frame(x = rnorm(n, 120, sd))
# Label groups and combine within single df
a$group <- 'a'
b$group <- 'b'
ab <- rbind(a, b)
# Store mean values in df
mean_df <- ab %>%
group_by(group) %>%
summarize(mean = mean(x))
# Calculate absolute mean difference
xbar_delta <- abs(round(mean(ab[ab$group == 'b', 'x']) - mean(ab[ab$group == 'a', 'x']), 0))
t_test <- t.test(ab[ab$group == 'a', 'x'], ab[ab$group == 'b', 'x'])
# Store viz to object
p[[i]] <- ggplot2::ggplot(ab, aes(x, fill = group)) +
ggplot2::labs(title = paste0("MD = ", xbar_delta, "\n t = ", round(t_test$statistic, 1), ifelse(t_test$p.value < .05, ", p < .05", ", p > .05")), x = "x", y = "Density") +
ggplot2::geom_density(alpha = 0.6) +
ggplot2::scale_fill_manual(values = c("skyblue", "lightgrey")) +
ggplot2::geom_vline(data = mean_df, aes(xintercept = mean), colour = c("blue", "#3D3D3D"), size = .5, linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::theme(legend.position = "none")
# Increment counter variable by 1
i = i + 1
}
}
# Visualize density plots side-by-side
ggpubr::ggarrange(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], p[[6]], p[[7]], p[[8]], p[[9]],
ncol = 3, nrow = 3)
# Load library
library(dplyr)
library(ggplot2)
# Set seed for reproducible random numbers
set.seed(123)
# Fill sample size vector
n_counts <- c(100, 1000, 10000)
# Fill sd vector
sds <- c(25, 50, 75)
# Initialize lists
p = list()
t_test = list()
# Initialize index
i = 1
for (n in n_counts){
for (sd in sds){
# Draw random numbers from normal distribution per defined parameters
a <- data.frame(x = rnorm(n, 100, sd))
b <- data.frame(x = rnorm(n, 120, sd))
# Label groups and combine within single df
a$group <- 'a'
b$group <- 'b'
ab <- rbind(a, b)
# Store mean values in df
mean_df <- ab %>%
group_by(group) %>%
summarize(mean = mean(x))
# Calculate absolute mean difference
xbar_delta <- abs(round(mean(ab[ab$group == 'b', 'x']) - mean(ab[ab$group == 'a', 'x']), 0))
t_test <- t.test(ab[ab$group == 'a', 'x'], ab[ab$group == 'b', 'x'])
# Store viz to object
p[[i]] <- ggplot2::ggplot(ab, aes(x, fill = group)) +
ggplot2::labs(title = paste0("MD = ", xbar_delta, "\n t = ", round(t_test$statistic, 1), ifelse(t_test$p.value < .05, ", p < .05", ", p > .05")), x = "x", y = "Density") +
ggplot2::geom_density(alpha = 0.6) +
ggplot2::scale_fill_manual(values = c("skyblue", "lightgrey")) +
ggplot2::geom_vline(data = mean_df, aes(xintercept = mean), colour = c("blue", "#3D3D3D"), size = .5, linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::theme(legend.position = "none")
# Increment counter variable by 1
i = i + 1
}
}
# Visualize density plots side-by-side
ggpubr::ggarrange(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], p[[6]], p[[7]], p[[8]], p[[9]],
ncol = 3, nrow = 3)
# Store results of Welch's t-test to object
t_test_rslts <- t.test(comp_mgr, comp_rsci)
# Store results of Welch's t-test to object
t_test_rslts <- t.test(comp_mgr, comp_rsci)
# Store results of Welch's t-test to object
t_rslts <- t.test(comp_mgr, comp_rsci)
t_rslts$method
# Store results of Welch's t-test to object
t_rslts <- t.test(comp_mgr, comp_rsci)
t_rslts$statistic # t-statistic
t_rslts$p.value # p-value
t_rslts$method # type of t-test
t_rslts$parameter
# Load library
library(dplyr)
library(ggplot2)
# Set seed for reproducible random numbers
set.seed(123)
# Fill sample size vector
n_counts <- c(100, 1000, 10000)
# Fill sd vector
sds <- c(25, 50, 75)
# Initialize lists
p = list()
t_test = list()
# Initialize index
i = 1
for (n in n_counts){
for (sd in sds){
# Draw random numbers from normal distribution per defined parameters
a <- data.frame(x = rnorm(n, 100, sd))
b <- data.frame(x = rnorm(n, 120, sd))
# Label groups and combine within single df
a$group <- 'a'
b$group <- 'b'
ab <- rbind(a, b)
# Store mean values in df
mean_df <- ab %>%
group_by(group) %>%
summarize(mean = mean(x))
# Calculate absolute mean difference
xbar_delta <- abs(round(mean(ab[ab$group == 'b', 'x']) - mean(ab[ab$group == 'a', 'x']), 0))
t_test <- t.test(ab[ab$group == 'a', 'x'], ab[ab$group == 'b', 'x'])
# Store viz to object
p[[i]] <- ggplot2::ggplot(ab, aes(x, fill = group)) +
ggplot2::labs(title = paste0("MD = ", xbar_delta, "\n t = ", round(t_test$statistic, 1), ifelse(t_test$p.value < .05, ", p < .05", ", p > .05")), x = "x", y = "Density") +
ggplot2::geom_density(alpha = 0.6) +
ggplot2::scale_fill_manual(values = c("skyblue", "lightgrey")) +
ggplot2::geom_vline(data = mean_df, aes(xintercept = mean), colour = c("blue", "#3D3D3D"), size = .5, linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::theme(legend.position = "none")
# Increment counter variable by 1
i = i + 1
}
}
# Visualize density plots side-by-side
ggpubr::ggarrange(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], p[[6]], p[[7]], p[[8]], p[[9]],
ncol = 3, nrow = 3)
# Load employee data
employees <- read.csv("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/data/employees.csv")
# Produce boxplots to visualize compensation distribution by education level and gender
ggplot2::ggplot(employees[employees$job_title %in% c('Manager', 'Research Scientist'), ], aes(x = as.factor(job_title), y = annual_comp, color = job_title)) +
ggplot2::labs(x = "Job Title", y = "Annual Compensation") +
ggplot2::theme_bw() +
ggplot2::geom_boxplot()
employees[employees$job_title %in% c('Manager', 'Research Scientist'), ]
# Produce boxplots to visualize compensation distribution by education level and gender
ggplot2::ggplot(employees[employees$job_title %in% c('Manager', 'Research Scientist'), ], aes(x = as.factor(job_title), y = annual_comp, color = job_title)) +
ggplot2::labs(x = "Job Title", y = "Annual Compensation") +
ggplot2::theme_bw() +
ggplot2::geom_boxplot()
# Produce boxplots to visualize compensation distribution by education level and gender
ggplot2::ggplot(employees, aes(x = as.factor(job_title), y = annual_comp, color = job_title)) +
ggplot2::labs(x = "Job Title", y = "Annual Compensation") +
ggplot2::theme_bw() +
ggplot2::geom_boxplot()
# Load library
library(ggplot2)
# Produce boxplots to visualize compensation distribution by education level and gender
ggplot2::ggplot(employees[employees$job_title %in% c('Manager', 'Research Scientist'), ], aes(x = as.factor(job_title), y = annual_comp, color = job_title)) +
ggplot2::labs(x = "Job Title", y = "Annual Compensation") +
ggplot2::theme_bw() +
ggplot2::geom_boxplot()
# Load library
library(ggplot2)
# Produce boxplots to visualize compensation distribution by education level and gender
ggplot2::ggplot(employees[employees$job_title %in% c('Manager', 'Research Scientist'), ], aes(x = as.factor(job_title), y = annual_comp, color = job_title)) +
ggplot2::labs(x = "Job Title", y = "Annual Compensation") +
ggplot2::guides(fill = guide_legend(title = "Job Title")) +
ggplot2::theme_bw() +
ggplot2::geom_boxplot()
subset(employees, job_title %in% c('Manager', 'Research Scientist'), select = c('annual_comp', 'job_title'))
data <- subset(employees, job_title %in% c('Manager', 'Research Scientist'), select = c('annual_comp', 'job_title'))
class(data)
mode(data)
data <- unlist(subset(employees, job_title %in% c('Manager', 'Research Scientist'), select = c('annual_comp', 'job_title')))
mode(data)
str(data)
data <- subset(employees, job_title %in% c('Manager', 'Research Scientist'), select = c('annual_comp', 'job_title'))
# Load library
library(ggplot2)
# Subset data
data <- subset(employees, job_title %in% c('Manager', 'Research Scientist'), select = c('annual_comp', 'job_title'))
# Produce boxplots to visualize compensation distribution by job title
ggplot2::ggplot(data, aes(x = as.factor(job_title), y = annual_comp, color = job_title)) +
ggplot2::labs(x = "Job Title", y = "Annual Compensation") +
ggplot2::theme_bw() +
ggplot2::geom_boxplot()
# Store mean values in df
mean_df <- data %>%
group_by(job_title) %>%
summarize(mean = mean(x))
# Load library
library(dplyr)
# Store mean values in df
mean_df <- data %>%
group_by(job_title) %>%
summarize(mean = mean(x))
# Load library
library(dplyr)
# Store mean values in df
mean_df <- data %>%
group_by(job_title) %>%
summarize(mean = mean(annual_comp))
# Produce density plots to visualize compensation distribution by job title
ggplot2::ggplot(data, aes(x, fill = job_title)) +
ggplot2::labs(x = "Annual Compensation", y = "Density") +
ggplot2::geom_density(alpha = 0.6) +
ggplot2::scale_fill_manual(values = c("skyblue", "lightgrey")) +
ggplot2::geom_vline(data = mean_df, aes(xintercept = mean), colour = c("blue", "#3D3D3D"), size = .5, linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::theme(legend.position = "none")
# Load library
library(dplyr)
# Store mean values in df
mean_df <- data %>%
group_by(job_title) %>%
summarize(mean = mean(annual_comp))
# Produce density plots to visualize compensation distribution by job title
ggplot2::ggplot(data, aes(annual_comp, fill = job_title)) +
ggplot2::labs(x = "Annual Compensation", y = "Density") +
ggplot2::geom_density(alpha = 0.6) +
ggplot2::scale_fill_manual(values = c("skyblue", "lightgrey")) +
ggplot2::geom_vline(data = mean_df, aes(xintercept = mean), colour = c("blue", "#3D3D3D"), size = .5, linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::theme(legend.position = "none")
# Load library
library(ggplot2)
# Subset data
data <- subset(employees, job_title %in% c('Manager', 'Research Scientist'), select = c(annual_comp, job_title))
# Produce boxplots to visualize compensation distribution by job title
ggplot2::ggplot(data, aes(x = as.factor(job_title), y = annual_comp, color = job_title)) +
ggplot2::labs(x = "Job Title", y = "Annual Compensation") +
ggplot2::theme_bw() +
ggplot2::geom_boxplot()
# Load library
library(ggplot2)
# Subset data
data <- subset(employees, job_title %in% c('Manager', 'Research Scientist'), select = c(annual_comp, job_title))
# Produce boxplots to visualize compensation distribution by job title
ggplot2::ggplot(data, aes(x = as.factor(job_title), y = annual_comp, color = job_title)) +
ggplot2::labs(x = "Job Title", y = "Annual Compensation") +
ggplot2::guides(col = guide_legend("Job Title")) +
ggplot2::theme_bw() +
ggplot2::geom_boxplot()
# Store results of Welch's t-test to object
t_rslts <- t.test(comp_mgr, comp_rsci)
# Create compensation vectors for two jobs
comp_mgr <- unlist(subset(employees, job_title == 'Manager', select = annual_comp))
comp_rsci <- unlist(subset(employees, job_title == 'Research Scientist', select = annual_comp))
# Run Welch's t-test
t.test(comp_mgr, comp_rsci)
# Store results of Welch's t-test to object
t_rslts <- t.test(comp_mgr, comp_rsci)
t_rslts$statistic # t-statistic
t_rslts$parameter # df
t_rslts$p.value # p-value
t_rslts$method # type of t-test
t_rslts
t_rslts[1]
length(t_rsslts)
length(t_rslts)
t_rslts$statistic # t-statistic
t_rslts[1]
# Load library
library(dplyr)
# Set seed for reproducible random numbers
set.seed(123)
# Fill sample size vector
n_counts <- c(100, 1000, 10000)
# Fill standard deviation vector
sds <- c(25, 50, 75)
# Initialize lists
p = list()
t_test = list()
# Initialize index
i = 1
for (n in n_counts){
for (sd in sds){
# Draw random numbers from normal distribution per defined parameters
a <- data.frame(x = rnorm(n, 100, sd))
b <- data.frame(x = rnorm(n, 120, sd))
# Label groups and combine within single df
a$group <- 'a'
b$group <- 'b'
ab <- rbind(a, b)
# Store mean values in df
mean_df <- ab %>%
group_by(group) %>%
summarize(mean = mean(x))
# Calculate absolute mean difference
xbar_delta <- abs(round(mean(ab[ab$group == 'b', 'x']) - mean(ab[ab$group == 'a', 'x']), 0))
t_test <- t.test(ab[ab$group == 'a', 'x'], ab[ab$group == 'b', 'x'])
# Store viz to object
p[[i]] <- ggplot2::ggplot(ab, aes(x, fill = group)) +
ggplot2::labs(title = paste0("MD = ", xbar_delta, "\n t = ", round(t_test$statistic, 1), ifelse(t_test$p.value < .05, ", p < .05", ", p > .05")), x = "x", y = "Density") +
ggplot2::geom_density(alpha = 0.6) +
ggplot2::scale_fill_manual(values = c("skyblue", "lightgrey")) +
ggplot2::geom_vline(data = mean_df, aes(xintercept = mean), colour = c("blue", "#3D3D3D"), size = .5, linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(plot.title = element_text(hjust = 0.5)) +
ggplot2::theme(legend.position = "none")
# Increment counter variable by 1
i = i + 1
}
}
# Visualize density plots side-by-side
ggpubr::ggarrange(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], p[[6]], p[[7]], p[[8]], p[[9]],
ncol = 3, nrow = 3)
# This assigns each element of results from Welch's t-test to an indexed position in the object
t_rslts <- t.test(comp_mgr, comp_rsci)
t_rslts$statistic # t-statistic
t_rslts$parameter # df
t_rslts$p.value # p-value
t_rslts$method # type of t-test
t_rslts
t_rslts[2]
t_rslts[3]
t_rslts[4]
t_rslts[5]
t_rslts[6]
t_rslts[7]
t_rslts[8]
t_rslts[9]
# This assigns each element of results from Welch's t-test to an indexed position in the object
t_rslts <- t.test(comp_mgr, comp_rsci)
t_rslts$statistic # t-statistic
t_rslts$parameter # df
t_rslts$p.value # p-value
t_rslts$method # type of t-test
t_rslts[1] # t-statistic
t_rslts[2] # df
t_rslts[3] # p-value
t_rslts[9] # type of t-test
# This assigns each element of results from Welch's t-test to an indexed position in the object
t_rslts <- t.test(comp_mgr, comp_rsci)
t_rslts$statistic # t-statistic
t_rslts$parameter # df
t_rslts$p.value # p-value
t_rslts$method # type of t-test
t_rslts[1] # t-statistic
t_rslts[2] # df
t_rslts[3] # p-value
t_rslts[9] # type of t-test
mode(t_rslts)
class(t_rslts)
str(t_rslts)
t_rslts[[1]]
t_rslts[[1]] # t-statistic
t_rslts[[2]] # df
t_rslts[[3]] # p-value
t_rslts[[9]] # type of t-test
t_rslts[[1]] # t-statistic
t_rslts[[2]] # df
t_rslts[[3]] # p-value
t_rslts[[9]] # type of t-test
t_rslts[1] # t-statistic
t_rslts[2] # df
t_rslts[3] # p-value
t_rslts[9] # type of t-test
t_rslts[1] # t-statistic
t_rslts[2] # df
t_rslts[3] # p-value
t_rslts[9] # type of t-test
# Create and fill matrix with numbers
matrix(1:4, 2, 2)
# Create and fill matrix with numbers
matrix(1:9, 3, 3)
# Create and fill matrix with numbers
matrix(1:9, 3, 3) * 2
# Multiply each matrix value by 2
matrix(1:9, 3, 3) * 2
# Create 3x3 matrix
matrix(1:9, 3, 3)
