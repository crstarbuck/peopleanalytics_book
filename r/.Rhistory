# Produce tabular summary for model results using flextable
flextable::as_flextable(slm.fit)
1/.2
1/.8
View(employees)
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(ytd_sales ~ engagement + job_lvl + work_exp + org_tenure + job_tenure + last_promo, data)
round(cor(subset(data, select = c(engagement, job_lvl, work_exp, org_tenure, job_tenure, last_promo)), 2))
View(data)
subset(data, select = c(engagement, job_lvl, work_exp, org_tenure, job_tenure, last_promo))
round(cor(unlist(subset(data, select = c(engagement, job_lvl, work_exp, org_tenure, job_tenure, last_promo))), 2))
round(cor(subset(data, select = c(engagement, job_lvl, work_exp, org_tenure, job_tenure, last_promo))), 2)
M1 <- round(cor(subset(data, select = c(engagement, job_lvl, work_exp, org_tenure, job_tenure, last_promo))), 2) # Build a correlation matrix named M1.
M1[M1 == 1] <- NA # Drop perfect correlations (relationships of variables with themselves)
M1 <- na.omit(reshape2::melt(M1)) # Convert columns into rows for ease of use
M1 <- M1[order(-abs(M1$value)),] # Sort order the data
M1 # Display contents of the matrix.
print(M1, row.names = FALSE) # Display contents of the matrix.
paste(M1) # Display contents of the matrix
print(M1) # Display contents of the matrix
print(M1, row.names = F) # Display contents of the matrix
print(M1, row.names = FALSE) # Display contents of the matrix
M1 <- round(cor(subset(data, select = c(engagement, job_lvl, work_exp, org_tenure, last_promo))), 2) # Build a correlation matrix named M1.
M1[M1 == 1] <- NA # Drop perfect correlations (relationships of variables with themselves)
M1 <- na.omit(reshape2::melt(M1)) # Convert columns into rows for ease of use
M1 <- M1[order(-abs(M1$value)), ] # Sort order the data
M1 # Display contents of the matrix
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(ytd_sales ~ engagement + job_lvl + work_exp + org_tenure + last_promo, data)
# Load library
library(car)
car:vif(mlm.fit)
# Load library
library(car)
car:vif(mlm.fit)
car::vif(mlm.fit)
library(flextable)
# Produce tabular summary for model results using flextable
flextable::as_flextable(mlm.fit)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(ytd_sales ~ job_lvl + work_exp + org_tenure + last_promo, data)
# Produce tabular summary for model results using flextable
flextable::as_flextable(mlm.fit)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Run the Breusch-Pagan test for evaluate homoscedasticity
lmtest::bptest(mlm.fit)
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(mlm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
# Compute Shapiro-Wilk test of normality
shapiro.test(mlm.fit$residuals)
mlm.fit <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + work_exp + org_tenure + last_promo, data)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
View(data)
data = data[-99,]
mlm.fit <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + work_exp + org_tenure + last_promo, data)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
?rstudentr
?rstudent
# Remove high leverage observations
w <- abs(rstudent(mlm.fit)) < 3 & abs(cooks.distance(mlm.fit)) < 4/nrow(mlm.fit$model)
mlm.fit <- update(mlm.fit, weights = as.numeric(w))
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + work_exp + org_tenure + last_promo, data)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit)) < 3 & abs(cooks.distance(mlm.fit)) < 4/nrow(mlm.fit$model)
mlm.fit <- update(mlm.fit, weights = as.numeric(w))
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Load library
library(dplyr)
# Load employee data
employees <- read.csv("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/data/employees.csv")
# Subset employees data frame; leads are only applicable for those in sales positions
data <- subset(employees, job_title %in% c('Sales Executive', 'Sales Representative'))
# Regress YTD leads on engagement
slm.fit <- lm(ytd_leads ~ engagement, data)
library(ggplot2)
extract_eq(slm.fit)
library(equatiomatic)
install.packages(equatiomatic, dependencies = TRUE)
install.packages("equatiomatic")
extract_eq(slm.fit)
library(equatiomatic)
extract_eq(slm.fit)
# Load library
library(equatiomatic)
# Convert model to LaTex regression equation
extract_eq(slm.fit)
# Load library
library(equatiomatic)
# Convert model to LaTex regression equation
extract_eq(slm.fit)
# Produce VIF for each predictor
pairs(data)
mode(data)
class(data)
View(data)
# Create pairs plot
pairs(subset(data, select = c(engagement, job_lvl, work_exp, org_tenure, last_promo)))
# Create pairs plot
pairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, org_tenure, last_promo)))
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(ytd_sales ~ engagement + job_lvl + work_exp + org_tenure + job_tenure + mgr_tenure + last_promo, data)
# Produce correlation matrix
GGally::ggpairs(subset(employees, select = c(ytd_sales, engagement, job_lvl, work_exp, org_tenure, last_promo)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, org_tenure, last_promo)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, org_tenure, last_promo)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, job_tenure, org_tenure, last_promo)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, job_tenure, org_tenure, last_promo)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, job_tenure, org_tenure, last_promo)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, job_tenure, org_tenure, last_promo)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, job_tenure, org_tenure, last_promo)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, job_tenure, org_tenure, mgr_tenure, last_promo)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, prior_emplr_cnt, job_tenure, org_tenure, mgr_tenure)))
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, stock_opt_lvl, job_tenure, org_tenure, mgr_tenure)))
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(ytd_sales ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(ytd_sales ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Load library
library(car)
# Produce VIF for each predictor
car::vif(mlm.fit)
# Load library
library(car)
# Produce VIF for each predictor
car::vif(mlm.fit)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit)) < 3 & abs(cooks.distance(mlm.fit)) < 4/nrow(mlm.fit$model)
mlm.fit <- update(mlm.fit, weights = as.numeric(w))
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Run the Breusch-Pagan test for evaluate homoscedasticity
lmtest::bptest(mlm.fit)
# Run the Breusch-Pagan test for evaluate homoscedasticity
lmtest::bptest(mlm.fit)
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(mlm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
# Compute Shapiro-Wilk test of normality
shapiro.test(mlm.fit$residuals)
mlm.fit <- lm(log(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit)) < 3 & abs(cooks.distance(mlm.fit)) < 4/nrow(mlm.fit$model)
mlm.fit <- update(mlm.fit, weights = as.numeric(w))
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(mlm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
# Compute Shapiro-Wilk test of normality
shapiro.test(mlm.fit$residuals)
mlm.fit <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit)) < 3 & abs(cooks.distance(mlm.fit)) < 4/nrow(mlm.fit$model)
mlm.fit <- update(mlm.fit, weights = as.numeric(w))
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(mlm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
# Compute Shapiro-Wilk test of normality
shapiro.test(mlm.fit$residuals)
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit)) < 3 & abs(cooks.distance(mlm.fit)) < 4/nrow(mlm.fit$model)
mlm.fit <- update(mlm.fit, weights = as.numeric(w))
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Run the Breusch-Pagan test for evaluate homoscedasticity
lmtest::bptest(mlm.fit)
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(mlm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
# Compute Shapiro-Wilk test of normality
shapiro.test(mlm.fit$residuals)
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(mlm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
# Compute Shapiro-Wilk test of normality
shapiro.test(mlm.fit$residuals)
library(flextable)
# Produce tabular summary for model results using flextable
flextable::as_flextable(mlm.fit)
# Load library
library(ggplot2)
# Generate data with a linear relationship + some noise
X <- rnorm(20, 50, 10)
err = rnorm(20, 0, 15)
Y <- 100 + 4*X + err
# Construct basic data frame
df2 <- data.frame(X = X,
Y = Y)
# Fit simple linear model to data
lm.fit.2 <- lm(Y ~ X, df2)
# Save predicted values and residuals
df2$predicted <- predict(lm.fit.2)
df2$residuals <- residuals(lm.fit.2)
# Visualize model fit to observations
ggplot2::ggplot(data = df2, aes(x = X, y = Y)) +
ggplot2::geom_segment(aes(xend = X, yend = predicted)) +
ggplot2::geom_point(shape = 1) +
ggplot2::geom_point(aes(y = predicted)) +
ggplot2::geom_function(fun = function(x) {lm.fit.2$coefficients[[2]]*x + lm.fit.2$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Load library
library(ggplot2)
# Generate data with a linear relationship + some noise
X <- rnorm(20, 50, 10)
err = rnorm(20, 0, 15)
Y <- 100 + 4*X + err
# Construct basic data frame
df2 <- data.frame(X = X,
Y = Y)
# Fit simple linear model to data
lm.fit.2 <- lm(Y ~ X, df2)
# Save predicted values and residuals
df2$predicted <- predict(lm.fit.2)
df2$residuals <- residuals(lm.fit.2)
# Visualize model fit to observations
ggplot2::ggplot(data = df2, aes(x = X, y = Y)) +
ggplot2::geom_segment(aes(xend = X, yend = predicted)) +
ggplot2::geom_point(shape = 1) +
ggplot2::geom_point(aes(y = predicted)) +
ggplot2::geom_function(fun = function(x) {lm.fit.2$coefficients[[2]]*x + lm.fit.2$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Set seed for reproducibility
set.seed(1234)
# Construct basic data frame
df1 <- data.frame(X = c(25, 75),
Y = c(205, 390))
# Fit simple linear model to data
lm.fit.1 <- lm(Y ~ X, df1)
# Visualize model fit to observations
p1 <- ggplot2::ggplot(data = df1, aes(x = X, y = Y)) +
ggplot2::geom_point(color = "black") +
ggplot2::geom_function(fun = function(x) {lm.fit.1$coefficients[[2]]*x + lm.fit.1$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Generate data with a linear relationship + some noise
X <- rnorm(20, 50, 10)
err = rnorm(20, 0, 15)
Y <- 100 + 4*X + err
# Construct basic data frame
df2 <- data.frame(X = X,
Y = Y)
# Fit simple linear model to data
lm.fit.2 <- lm(Y ~ X, df2)
# Visualize model fit to observations
p2 <- ggplot2::ggplot(data = df2, aes(x = X, y = Y)) +
ggplot2::geom_point() +
ggplot2::geom_function(fun = function(x) {lm.fit.2$coefficients[[2]]*x + lm.fit.2$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Display distribution visualizations
ggpubr::ggarrange(p1, p2, ncol = 2, nrow = 1)
# Load library
library(dplyr)
# Load employee data
employees <- read.csv("/Users/craig.starbuck/Library/Mobile Documents/com~apple~CloudDocs/Documents/People Analytics Book/GitHub/peopleanalytics_lifecycle_book/data/employees.csv")
# Subset employees data frame; leads are only applicable for those in sales positions
data <- subset(employees, job_title %in% c('Sales Executive', 'Sales Representative'))
# Regress YTD leads on engagement
slm.fit <- lm(ytd_leads ~ engagement, data)
# Set seed for reproducibility
set.seed(1234)
# Simulate n observations
n <- 20
X <- runif(n, 0, 5)
Y <- 1 + 3*X + rnorm(n, 0, 1)
df.orig <- data.frame(X = X, Y = Y)
# Model data
model <- lm(Y ~ X)
summary(model)
# Visualize model fit to observations
p1 <- ggplot2::ggplot(data = df.orig, aes(x = X, y = Y)) +
ggplot2::geom_point() +
ggplot2::geom_function(fun = function(x) {model$coefficients[[2]]*x + model$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Model data with non-influential outliers
X.out <- c(X, 8)
Y.out <- c(Y, 25)
df.out <- data.frame(X = X.out, Y = Y.out)
model.out <- lm(Y.out ~ X.out)
summary(model.out)
# Visualize model fit to observations
p2 <- ggplot2::ggplot(data = df.out, aes(x = X, y = Y)) +
ggplot2::geom_point(col = ifelse(df.out$X == 8, "red", "black"), size = ifelse(df.out$X == 8, 2, 1)) +
ggplot2::geom_function(fun = function(x) {model$coefficients[[2]]*x + model$coefficients[[1]]}, colour = "black", linetype = "solid") +
ggplot2::geom_function(fun = function(x) {model.out$coefficients[[2]]*x + model.out$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Model data with influential (high leverage) observations
X.lev <- c(X, 8)
Y.lev <- c(Y, 5)
df.lev <- data.frame(X = X.lev, Y = Y.lev)
model.lev <- lm(Y.lev ~ X.lev)
summary(model.lev)
# Visualize model fit to observations
p3 <- ggplot2::ggplot(data = df.lev, aes(x = X, y = Y)) +
ggplot2::geom_point(col = ifelse(df.out$X == 8, "red", "black"), size = ifelse(df.out$X == 8, 2, 1)) +
ggplot2::geom_function(fun = function(x) {model$coefficients[[2]]*x + model$coefficients[[1]]}, colour = "black", linetype = "solid") +
ggplot2::geom_function(fun = function(x) {model.lev$coefficients[[2]]*x + model.lev$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::theme_bw() +
ggplot2::theme(axis.title.y = element_text(face = "italic"), axis.title.x = element_text(face = "italic"))
# Display distribution visualizations
ggpubr::ggarrange(p2, p3, ncol = 2, nrow = 1)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(slm.fit)
# Run the Breusch-Pagan test for evaluate homoscedasticity
lmtest::bptest(slm.fit)
# Square root transformation of YTD leads
slm.fit.trans <- lm(sqrt(ytd_leads) ~ engagement, data)
# Natural logarithmic transformation of YTD leads
slm.fit.trans <- lm(log(ytd_leads) ~ engagement, data)
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(slm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
ggplot2::ggplot(data = data, aes(x = engagement, y = ytd_leads)) +
ggplot2::labs(x = "Engagement", y = "YTD Leads") +
ggplot2::geom_point(color = "black") +
ggplot2::geom_function(fun = function(x) {slm.fit$coefficients[[2]]*x + slm.fit$coefficients[[1]]}, colour = "red", linetype = "dashed") +
ggplot2::annotate("text", x = 1.4, y = 40, label = "y = 20.1x + 1.6", colour = "red") +
ggplot2::theme_bw()
# Load library
library(equatiomatic)
# Convert model to LaTex regression equation
extract_eq(slm.fit)
# Produce correlation matrix
GGally::ggpairs(subset(data, select = c(ytd_sales, engagement, job_lvl, work_exp, stock_opt_lvl, job_tenure, org_tenure, mgr_tenure)))
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(ytd_sales ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(ytd_sales ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Load library
library(car)
# Produce VIF for each predictor
car::vif(mlm.fit)
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit)) < 3 & abs(cooks.distance(mlm.fit)) < 4/nrow(mlm.fit$model)
mlm.fit <- update(mlm.fit, weights = as.numeric(w))
# Regress YTD sales on a combination of predictors
mlm.fit <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit)) < 3 & abs(cooks.distance(mlm.fit)) < 4/nrow(mlm.fit$model)
mlm.fit <- update(mlm.fit, weights = as.numeric(w))
# Produce 2x2 visuals for model diagnostics
par(mfrow = c(2,2))
plot(mlm.fit)
# Run the Breusch-Pagan test for evaluate homoscedasticity
lmtest::bptest(mlm.fit)
# Produce histogram to visualize distribution of model residuals
ggplot2::ggplot() +
ggplot2::aes(mlm.fit$residuals) +
ggplot2::labs(x = "YTD Leads Residuals", y = "Density") +
ggplot2::geom_histogram(aes(y = ..density..), fill = "#414141") +
ggplot2::geom_density(fill = "#ADD8E6", alpha = 0.6) +
ggplot2::theme_bw()
# Compute Shapiro-Wilk test of normality
shapiro.test(mlm.fit$residuals)
# Produce tabular summary for model results using flextable
flextable::as_flextable(mlm.fit)
unique(data$job_lvl)
unique(data$org_tenure)
unique(data$stock_opt_lvl)
max(data$org_tenure)
lapply(data[, all.vars(mlm.fit)], scale)
mlm.fit.scaled <- lm(sqrt(ytd_sales) ~ scale(engagement) + scale(job_lvl) + scale(stock_opt_lvl) + scale(org_tenure), data)
# Scale predictors for standardized coefficients
mlm.fit.scaled <- lm(sqrt(ytd_sales) ~ scale(engagement) + scale(job_lvl) + scale(stock_opt_lvl) + scale(org_tenure), data)
# Produce tabular summary for model results using flextable
flextable::as_flextable(mlm.fit.scaled)
# Scale predictors for standardized coefficients
mlm.fit.scaled <- lm(scale(sqrt(ytd_sales)) ~ scale(engagement) + scale(job_lvl) + scale(stock_opt_lvl) + scale(org_tenure), data)
# Produce tabular summary for model results using flextable
flextable::as_flextable(mlm.fit.scaled)
# Scale predictors for standardized coefficients
mlm.fit.scaled <- lm(sqrt(ytd_sales) ~ scale(engagement) + scale(job_lvl) + scale(stock_opt_lvl) + scale(org_tenure), data)
# Produce tabular summary for model results using flextable
flextable::as_flextable(mlm.fit.scaled)
data_std = data.frame(scale(data))
data_std = data.frame(scale(subset(data, select = (c(ytd_sales, engagement, job_lvl, stock_opt_lvl, org_tenure)))))
data_std
data_std = data.frame(scale(subset(data, select = (c(ytd_sales, engagement, job_lvl, stock_opt_lvl, org_tenure)))))
# Scale predictors for standardized coefficients
mlm.fit.scaled <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_std)
data_std = data.frame(scale(subset(data, select = (c(ytd_sales, engagement, job_lvl, stock_opt_lvl, org_tenure)))))
# Scale predictors for standardized coefficients
mlm.fit.scaled <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_std)
# Produce tabular summary for model results using flextable
flextable::as_flextable(mlm.fit.scaled)
data_std = data.frame(scale(subset(data, select = (c(ytd_sales, engagement, job_lvl, stock_opt_lvl, org_tenure)))))
# Scale predictors for standardized coefficients
mlm.fit.scaled <- lm(ytd_sales ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_std)
# Produce tabular summary for model results using flextable
flextable::as_flextable(mlm.fit.scaled)
View(data)
ubset(data, overtime == 'Yes')
subset(data, overtime == 'Yes')
data_ot <- subset(data, overtime == 'Yes')
data_nonot <- subset(data, overtime == 'No')
# Regress transformed YTD sales on a combination of predictors
mlm.fit.ot <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_ot)
# Regress transformed YTD sales on a combination of predictors for overtime and non-overtime groups
mlm.fit.ot <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_ot)
mlm.fit.nonot <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_nonot)
# Produce tabular summary with standardized coefficients
flextable::as_flextable(mlm.fit.ot)
flextable::as_flextable(mlm.fit.nonot)
```{r, message = FALSE, warning = FALSE}
# Produce tabular summary with standardized coefficients
flextable::as_flextable(mlm.fit.ot)
# Produce tabular summary with standardized coefficients
flextable::as_flextable(mlm.fit.nonot)
# Partition data into overtime and non-overtime groups
data_ot <- subset(data, overtime == 'Yes')
data_nonot <- subset(data, overtime == 'No')
# Regress transformed YTD sales on a combination of predictors for overtime and non-overtime groups
mlm.fit.ot <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_ot)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit.ot)) < 3 & abs(cooks.distance(mlm.fit.ot)) < 4/nrow(mlm.fit.ot$model)
mlm.fit.ot <- update(mlm.fit.ot, weights = as.numeric(w))
# Regress transformed YTD sales on a combination of predictors for overtime and non-overtime groups
mlm.fit.nonot <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_nonot)
# Remove high leverage observations per Cook's distance
w <- abs(rstudent(mlm.fit.nonot)) < 3 & abs(cooks.distance(mlm.fit.nonot)) < 4/nrow(mlm.fit.nonot$model)
mlm.fit.nonot <- update(mlm.fit.nonot, weights = as.numeric(w))
# Produce tabular summary with standardized coefficients
flextable::as_flextable(mlm.fit.ot)
# Produce tabular summary with standardized coefficients
flextable::as_flextable(mlm.fit.nonot)
# Partition data into overtime and non-overtime groups
data_ot <- subset(data, overtime == 'Yes')
data_nonot <- subset(data, overtime == 'No')
# Regress transformed YTD sales on a combination of predictors for overtime and non-overtime groups
mlm.fit.ot <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_ot)
# Regress transformed YTD sales on a combination of predictors for overtime and non-overtime groups
mlm.fit.nonot <- lm(sqrt(ytd_sales) ~ engagement + job_lvl + stock_opt_lvl + org_tenure, data_nonot)
plot(mlm.fit.ot)
plot(mlm.fit.nonot)
